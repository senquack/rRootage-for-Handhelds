/*
 * $Id: screen.c,v 1.6 2003/08/10 03:21:28 kenta Exp $
 *
 * Copyright 2003 Kenta Cho. All rights reserved.
 */

/**
 * OpenGL screen handler.
 *
 * @version $Revision: 1.6 $
 */
#include <stdio.h>
#include <stdlib.h>

//#include "SDL.h"
//#include "SDL_mixer.h"
//#include "SDL_image.h"


//senquack
//#include "minimal.h"

#include <math.h>
#include <string.h>

#include "genmcr.h"
#include "screen.h"
#include "rr.h"
#include "degutil.h"
#include "attractmanager.h"
#include "letterrender.h"
#include "boss_mtd.h"

////senquack - added for gp2x volume control:
#include "soundmanager.h"

#define FAR_PLANE 720

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240
#define LOWRES_SCREEN_WIDTH 320
#define LOWRES_SCREEN_HEIGHT 240
#define SHARE_LOC "rr_share/"

static int screenWidth, screenHeight;

//senquack - for wiz OpenGLES
EGLDisplay      glDisplay;
EGLConfig       glConfig;
EGLContext      glContext;
EGLSurface      glSurface;
NativeWindowType hNativeWnd = 0;

EGLint attrib_list_fsaa[] =
{
  EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
  EGL_BUFFER_SIZE,  0,
  EGL_DEPTH_SIZE,   16,
  EGL_SAMPLE_BUFFERS, 1,
  EGL_SAMPLES,        4,
  EGL_NONE
};

EGLint attrib_list[] =
{
  EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
  EGL_BUFFER_SIZE,  0,
  EGL_DEPTH_SIZE,   16,
  EGL_NONE
};

///* SDL window */
//SDL_WindowID window;
///* SDL GL ES context, binded to SDL window */
//SDL_GLContext glcontext=NULL;

//senquack - experiment 2/12 (none of this appears linked to problem)
// Reset viewport when the screen is resized.
//static void screenResized() {
//  glViewport(0, 0, screenWidth, screenHeight);
//  glMatrixMode(GL_PROJECTION);
//  glLoadIdentity();
//  gluPerspective(45.0f, (GLfloat)screenWidth/(GLfloat)screenHeight, 0.1f, FAR_PLANE);
//  glMatrixMode(GL_MODELVIEW);
//}
static void screenResized() {
	//senquack - do we really need to call glViewport every single screen refresh!?
  glViewport(0, 0, screenWidth, screenHeight);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, (GLfloat)screenWidth/(GLfloat)screenHeight, 0.1f, FAR_PLANE);
  glMatrixMode(GL_MODELVIEW);
}

void resized(int width, int height) {
  screenWidth = width; screenHeight = height;
  screenResized();
}

////Added for gpu940
void gluPerspective(GLfloat fovy, GLfloat ratio, GLfloat near, GLfloat far)
{
	GLfloat top = near * tan(fovy * M_PI/360.0f);
	GLfloat bottom = -top;
	GLfloat right = top * ratio;
	GLfloat left = -right;

	glFrustum(left, right, bottom, top, near, far);
} 

////senquack - added for Wiz (pulled from libglues)
//#define __glPi 3.14159265358979323846
//
////senquack - added for Wiz (pulled from libglues)
//static void __gluMakeIdentityf(GLfloat m[16])
//{
//    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
//    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
//    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
//    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
//}
//
////senquack - added for Wiz (pulled from libglues)
//static void gluPerspective(GLfloat fovy, GLfloat aspect, GLfloat zNear, GLfloat zFar)
//{
//    GLfloat m[4][4];
//    GLfloat sine, cotangent, deltaZ;
//    GLfloat radians = fovy / 2 * __glPi / 180;
//
//    deltaZ = zFar - zNear;
//    sine = sin(radians);
//    if ((deltaZ == 0) || (sine == 0) || (aspect == 0))
//    {
//        return;
//    }
//    cotangent = cos(radians) / sine;
//
//    __gluMakeIdentityf(&m[0][0]);
//    m[0][0] = cotangent / aspect;
//    m[1][1] = cotangent;
//    m[2][2] = -(zFar + zNear) / deltaZ;
//    m[2][3] = -1;
//    m[3][2] = -2 * zNear * zFar / deltaZ;
//    m[3][3] = 0;
//    glMultMatrixf(&m[0][0]);
//}

//senquack - 2/12
// Init OpenGL.
//static void initGL() 
//{
//  printf("Opening gpu940\n"); 
//
//  //senquack
//  glOpen(DEPTH_BUFFER); //Added for gpu940
//
//  printf("Opened gpu940\n");
//  glViewport(0, 0, screenWidth, screenHeight);
//  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
//
//  glLineWidth(1);
//  glEnable(GL_LINE_SMOOTH);
//
//  //senquack - tried tweaking this to fix hang:
//  glEnable(GL_BLEND);
//  //glBlendFunc(GL_SRC_ALPHA, GL_ONE);
//  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
//
//  
//  //senquack
//  //Added for gpu940
//  glDepthMask(GL_TRUE);
//
//  glDisable(GL_LIGHTING);
//  glDisable(GL_CULL_FACE);
//  glDisable(GL_DEPTH_TEST);
//  glDisable(GL_TEXTURE_2D);
//  glDisable(GL_COLOR_MATERIAL);
//
//  resized(screenWidth, screenHeight);
//}
// Init OpenGL.
static void initGL() 
{
  printf("Opening gpu940\n"); 

  //senquack - why do we need a depth buffer?
//  glOpen(DEPTH_BUFFER); //Added for gpu940
//  glOpen(0);
//
//  printf("Opened gpu940\n");

//senquack - for wiz OpenGLES
    nanoGL_Init();

    // Create native window.
    printf( "VID_Init: Creating the window\n" ); 
    hNativeWnd = OS_CreateWindow();	                  
    if(!hNativeWnd)
    printf( "VID_Init: OS_CreateWindow Failed\n" ); 

	EGLint numConfigs;
	EGLint majorVersion;
	EGLint minorVersion;
	
	glDisplay = eglGetDisplay( (NativeDisplayType)0 );
	if( glDisplay == EGL_NO_DISPLAY )
	{
		printf( "GL No Display failed\n" );
	}
	
	if( !eglInitialize( glDisplay, &majorVersion, &minorVersion ) ) 
	{
		printf( "GL Init failed\n" );
	}
	if( !eglChooseConfig( glDisplay, attrib_list, &glConfig, 1, &numConfigs ) )
	{
		printf( "GL Config failed\n" );
	}
	glContext = eglCreateContext( glDisplay, glConfig, NULL, NULL );
	if( glContext==0 )
	{
		printf( "GL Context failed\n" );
	}
	glSurface = eglCreateWindowSurface( glDisplay, glConfig, hNativeWnd, NULL );
	if( glSurface==0 )
	{
		printf( "GL Surface failed\n" );
	}
	printf( "EGL Init Completed\n" );
	
	eglMakeCurrent( glDisplay, glSurface, glSurface, glContext );    

  glViewport(0, 0, screenWidth, screenHeight);
  //senquack - tried disabling:
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

//  glLineWidth(1);
	// On Wiz, we need to set this differently:
  glLineWidthx(f2x(1.0));

//  glEnable(GL_LINE_SMOOTH);
  glEnable(GL_LINE_SMOOTH);

  //senquack - tried tweaking this to fix hang:
  glEnable(GL_BLEND);
  //glBlendFunc(GL_SRC_ALPHA, GL_ONE);
  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

  
  //senquack
  //Added for gpu940
//  glDepthMask(GL_TRUE);

  glDisable(GL_LIGHTING);
  glDisable(GL_CULL_FACE);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_TEXTURE_2D);
  glDisable(GL_COLOR_MATERIAL);

  resized(screenWidth, screenHeight);
}


//senquack - 2/11 - disabled for now:
// Load bitmaps and convert to textures.
void loadGLTexture(char *fileName, GLuint *texture)
{  
//  SDL_Surface *surface;
//  int mode; //The bit-depth of the texture.
//  char name[32];
//  strcpy(name, SHARE_LOC);
//  strcat(name, "images/");
//  strcat(name, fileName);
//
//  surface = IMG_Load(name); //Changed by Albert... this will load any image (hopefully transparent PNGs)
//  if ( !surface ) {
//    fprintf(stderr, "Unable to load texture: %s\n", SDL_GetError());
//    SDL_Quit();
//    exit(1);
//  }
//  
//  surface = conv_surf_gl(surface, surface->format->Amask || (surface->flags & SDL_SRCCOLORKEY));
//
///*
//	//Attempted hackery to make transparencies/color-keying work - Albert
//	SDL_PixelFormat RGBAFormat;
//	RGBAFormat.palette = 0; RGBAFormat.colorkey = 0; RGBAFormat.alpha = 0;
//	RGBAFormat.BitsPerPixel = 32; RGBAFormat.BytesPerPixel = 4;
//	#if SDL_BYTEORDER == SDL_BIG_ENDIAN
//	RGBAFormat.Rmask = 0xFF000000; RGBAFormat.Rshift = 0; RGBAFormat.Rloss = 0;
//	RGBAFormat.Gmask = 0x00FF0000; RGBAFormat.Gshift = 8; RGBAFormat.Gloss = 0;
//	RGBAFormat.Bmask = 0x0000FF00; RGBAFormat.Bshift = 16; RGBAFormat.Bloss = 0;
//	RGBAFormat.Amask = 0x000000FF; RGBAFormat.Ashift = 24; RGBAFormat.Aloss = 0;
//	#else
//	RGBAFormat.Rmask = 0x000000FF; RGBAFormat.Rshift = 24; RGBAFormat.Rloss = 0;
//	RGBAFormat.Gmask = 0x0000FF00; RGBAFormat.Gshift = 16; RGBAFormat.Gloss = 0;
//	RGBAFormat.Bmask = 0x00FF0000; RGBAFormat.Bshift = 8; RGBAFormat.Bloss = 0;
//	RGBAFormat.Amask = 0xFF000000; RGBAFormat.Ashift = 0; RGBAFormat.Aloss = 0;
//	#endif
//*/
//
//
//  /* Create the target alpha surface with correct color component ordering */
///*
//  SDL_Surface *alphaImage = SDL_CreateRGBSurface( SDL_SWSURFACE, surface->w,
// 	surface->h, 32,
//#if SDL_BYTEORDER == SDL_LIL_ENDIAN // OpenGL RGBA masks 
//                               0x000000FF, 
//                               0x0000FF00, 
//                               0x00FF0000, 
//                               0xFF000000
//#else
//                               0xFF000000,
//                               0x00FF0000, 
//                               0x0000FF00, 
//                               0x000000FF
//#endif
//  );
//  
//  if (alphaImage == 0)
//  	printf("ruh oh, alphaImage creation failed in loadGLTexture() (screen.c)\n");
//*/
//
//  // Set up so that colorkey pixels become transparent :
// /* Uint32 colorkey = SDL_MapRGBA(alphaImage->format, 255, 255, 0, 0); //R=255, G=255, B=0
//  SDL_FillRect(alphaImage, 0, colorkey);
//
//  colorkey = SDL_MapRGBA(surface->format, 255, 255, 0, 0 );
//  SDL_SetColorKey(surface, SDL_SRCCOLORKEY, colorkey);
//
//
//  SDL_Rect area;
// 
//  // Copy the surface into the GL texture image : 
//  area.x = 0;
//  area.y = 0; 
//  area.w = surface->w;
//  area.h = surface->h;
//  SDL_BlitSurface(surface, &area, alphaImage, &area);
//*/
//
///*
//  for (int i = 0; i < conv->w * conv->h; i++)
//  {
//      
//  }
//*/
//
//  //SDL_Surface *conv = SDL_ConvertSurface(surface, &RGBAFormat, SDL_SWSURFACE);
//
////http://osdl.sourceforge.net/OSDL/OSDL-0.3/src/doc/web/main/documentation/rendering/SDL-openGL-examples.html
////http://osdl.sourceforge.net/main/documentation/rendering/SDL-openGL.html --> Good explainations
//
//    // work out what format to tell glTexImage2D to use...
//    if (surface->format->BytesPerPixel == 3) { // RGB 24bit
//		mode = GL_RGB;
//    } else if (surface->format->BytesPerPixel == 4) { // RGBA 32bit
//        mode = GL_RGBA;
//    }
//    else {
//    	printf("loadGLTexture: Error: Weird RGB mode found in surface.\n");
//    	SDL_Quit();
//    }
//
//  //Disabled for gpu940
//  glGenTextures(1, texture);
//  glBindTexture(GL_TEXTURE_2D, *texture);
//  //glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
//  //glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
//  //Disabled for gpu940
//  //gluBuild2DMipmaps(GL_TEXTURE_2D, 3, surface->w, surface->h, GL_RGB, GL_UNSIGNED_BYTE, surface->pixels);
//  
//  if (surface == NULL)
//  {
//     printf("Error: surface NULL in loadGLTexture.\n");
//     SDL_Quit();
//  }
//  
//   //Added by Albert (somehow Kenta Cho managed to get OpenGL to render SDL textures, looks like)
//   glTexImage2D( GL_TEXTURE_2D, 0, mode, surface->w, surface->h, 0,
//                      mode, GL_UNSIGNED_BYTE, surface->pixels );
//                      
//   //Added by Albert
//   if (surface)
//      SDL_FreeSurface(surface);     
//   //if (alphaImage)
//   //   SDL_FreeSurface(alphaImage);   
//   //if (conv)
//   //   SDL_FreeSurface(conv);                      
}


//senquack - 2/11 - disabled for now:
void generateTexture(GLuint *texture) {
//  glGenTextures(1, texture);
}

//senquack - 2/11 - disabled for now:
void deleteTexture(GLuint *texture) {
//  glDeleteTextures(1, texture);
}

static GLuint starTexture;
#define STAR_BMP "star.bmp"
static GLuint smokeTexture;
#define SMOKE_BMP "smoke.bmp"
static GLuint titleTexture;
#define TITLE_BMP "title.bmp"

int lowres = 0;
int windowMode = 0;
int brightness = DEFAULT_BRIGHTNESS;
//Uint8 *keys;
SDL_Joystick *stick = NULL;
int joystickMode = 1;


void initSDL() {
  Uint32 videoFlags;

  if ( lowres ) {
    screenWidth  = LOWRES_SCREEN_WIDTH;
    screenHeight = LOWRES_SCREEN_HEIGHT;
  } else {
    screenWidth  = SCREEN_WIDTH;
    screenHeight = SCREEN_HEIGHT;
  }

////senquack - for Wiz Opengl, re-enable this:
//  /* Initialize SDL */
//  if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {
//    fprintf(stderr, "Unable to initialize SDL: %s\n", SDL_GetError());
//    exit(1);
//  }
  
 // if ( SDL_InitSubSystem(SDL_INIT_JOYSTICK) < 0 ) {
  if ( SDL_Init(SDL_INIT_JOYSTICK) < 0 ) {
    fprintf(stderr, "Unable to initialize SDL_JOYSTICK: %s\n", SDL_GetError());
    joystickMode = 0;
    exit(1);
  }
  
//Changed for gpu940:
  /* Create an OpenGL screen */
  //if ( windowMode ) {
  	
  	//videoFlags = SDL
    //videoFlags = SDL_OPENGL | SDL_RESIZABLE;
  //} else {
    //videoFlags = SDL_OPENGL | SDL_FULLSCREEN;
  //}

  /*if ( SDL_SetVideoMode(screenWidth, screenHeight, 16, videoFlags) == NULL ) {
    fprintf(stderr, "Unable to create OpenGL screen: %s\n", SDL_GetError());
    SDL_Quit();
    exit(2);
  }*/

//senquack - for Wiz Opengl, re-enable this:
//senquack - leaving OPENGL here causes segfault:
//    videoFlags = SDL_OPENGL | SDL_FULLSCREEN;
//    videoFlags = SDL_FULLSCREEN;
//  if ( SDL_SetVideoMode(screenWidth, screenHeight, 16, videoFlags) == NULL ) {
//    fprintf(stderr, "Unable to create OpenGL screen: %s\n", SDL_GetError());
//    SDL_Quit();
//    exit(2);
//	}

//    /* Select first display */
//  	int status;
//    status=SDL_SelectVideoDisplay(0);
//    if (status<0)
//    {
//        fprintf(stderr, "Can't attach to first display: %s\n", SDL_GetError());
//        exit(-1);
//    }
//
////    window=SDL_CreateWindow("Nehe: SDL/OpenGL ES Tutorial, Lesson 02",
////        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
////        WINDOW_WIDTH, WINDOW_HEIGHT,
////        SDL_WINDOW_RESIZABLE | SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
//    window=SDL_CreateWindow("rRootage",
//        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
//        320, 240,
////        SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS | SDL_WINDOW_FULLSCREEN );
//        SDL_WINDOW_RESIZABLE | SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN | SDL_WINDOW_FULLSCREEN);
////		  | SDL_WINDOW_FOREIGN);
//    if (window==0)
//    {
//        fprintf(stderr, "Can't create window: %s\n", SDL_GetError());
//        SDL_Quit();
//    }
//
//    glcontext=SDL_GL_CreateContext(window);
//    if (glcontext==NULL)
//    {
//        fprintf(stderr, "Can't create OpenGL ES context: %s\n", SDL_GetError());
//        SDL_Quit();
//    }
//
//    status=SDL_GL_MakeCurrent(window, glcontext);
//    if (status<0)
//    {
//        fprintf(stderr, "Can't set current OpenGL ES context: %s\n", SDL_GetError());
//        SDL_Quit();
//    }
//
//    /* Enable swap on VSYNC */
//    SDL_GL_SetSwapInterval(1);

  if (joystickMode == 1) {
  	SDL_JoystickEventState(SDL_ENABLE);
    stick = SDL_JoystickOpen(0);
  }

  /* Set the title bar in environments that support it */
  SDL_WM_SetCaption(CAPTION, NULL);

//senquack - was left enabled for Wiz accidentally:
  initGL();

//  loadGLTexture(STAR_BMP, &starTexture);
//  loadGLTexture(SMOKE_BMP, &smokeTexture);
//  loadGLTexture(TITLE_BMP, &titleTexture);

  SDL_ShowCursor(SDL_DISABLE);
  
}

void closeSDL() {
	//senquack
//  SDL_ShowCursor(SDL_ENABLE);
//  glClose();

//senquack - for wiz OpenGLES
	eglMakeCurrent( glDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
	eglDestroySurface( glDisplay, glSurface ); 
	eglDestroyContext( glDisplay, glContext );
	eglTerminate( glDisplay );  

	nanoGL_Destroy();    

//    /* clean up the window */
//    SDL_GL_DeleteContext(glcontext);
//    SDL_DestroyWindow(window);


//senquack - experiment here for Wiz:
    	SDL_Quit();
}

float zoom = 15;
static int screenShakeCnt = 0;
static int screenShakeType = 0;

//senquack - experiment 2/12:
//static void setEyepos() {
//  float x, y;
//  glPushMatrix();
//  if ( screenShakeCnt > 0 ) {
//    switch ( screenShakeType ) {
//    case 0:
//      x = (float)randNS2(256)/5000.0f;
//      y = (float)randNS2(256)/5000.0f;
//      break;
//    default:
//      x = (float)randNS2(256)*screenShakeCnt/21000.0f;
//      y = (float)randNS2(256)*screenShakeCnt/21000.0f;
//      break;
//    }
//    gluLookAt(0, 0, zoom, x, y, 0, 0.0f, 1.0f, 0.0f); //changed for gpu940
//  } else {
//    gluLookAt(0, 0, zoom, 0, 0, 0, 0.0f, 1.0f, 0.0f); //changed for gpu940
//  }
//}
static void setEyepos() {
  float x, y;
  glPushMatrix();
  if ( screenShakeCnt > 0 ) {
    switch ( screenShakeType ) {
    case 0:
      x = (float)randNS2(256)/5000.0f;
      y = (float)randNS2(256)/5000.0f;
      break;
    default:
      x = (float)randNS2(256)*screenShakeCnt/21000.0f;
      y = (float)randNS2(256)*screenShakeCnt/21000.0f;
      break;
    }
    gluLookAt(0, 0, zoom, x, y, 0, 0.0f, 1.0f, 0.0f); //changed for gpu940
  } else {
		 gluLookAt(0, 0, zoom, 0, 0, 0, 0.0f, 1.0f, 0.0f); //changed for gpu940
  }
}

void setScreenShake(int type, int cnt) {
  screenShakeType = type; screenShakeCnt = cnt;
}

void moveScreenShake() {
  if ( screenShakeCnt > 0 ) {
    screenShakeCnt--;
  }
}

//senquack - experiment 2/12 (failed)
//void drawGLSceneStart() {
//  glClear(GL_COLOR_BUFFER_BIT);
//  setEyepos();
//}
void drawGLSceneStart() {
  glClear(GL_COLOR_BUFFER_BIT);
//  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  setEyepos();
}

void drawGLSceneEnd() {
  glPopMatrix();
}

void swapGLScene() {
  //SDL_GL_SwapBuffers(); //Switched to glSwapBuffers() for gpu940
  
  
//  glSwapBuffers();

//senquack - for wiz OpenGLES
    eglSwapBuffers(glDisplay,glSurface);
  
  //Believe it or not, this does fail sometimes... - Albert
  //if (glSwapBuffers() != GL_TRUE)
  //	printf("glSwapBuffers failed!!\n");
}

// NOTE
//senquack - disabling these next 3-4 functions allowed program to run longer before hang:

// 2/11 - new efforts to convert all triangle fans to something else:
//  //senquack - tried tweaking this to fix hang:
//void drawBox(GLfloat x, GLfloat y, GLfloat width, GLfloat height,
//	     int r, int g, int b) {
////  glPushMatrix();
////  glTranslatef(x, y, 0);
////  glColor4i(r, g, b, 128);
////  glBegin(GL_TRIANGLE_FAN);
////  glVertex3f(-width, -height,  0);
////  glVertex3f( width, -height,  0);
////  glVertex3f( width,  height,  0);
////  glVertex3f(-width,  height,  0);
////  glEnd();
////  glColor4i(r, g, b, 255);
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(-width, -height,  0);
////  glVertex3f( width, -height,  0);
////  glVertex3f( width,  height,  0);
////  glVertex3f(-width,  height,  0);
////  glEnd();
////  glPopMatrix();
//}
  //senquack - tried tweaking this to fix hang:
void drawBox(GLfloat x, GLfloat y, GLfloat width, GLfloat height,
	     int r, int g, int b) {
  glPushMatrix();
  glTranslatef(x, y, 0);
  glColor4i(r, g, b, 128);
//  glColor4f(r, g, b, 0.5);

  //senquack - added disabling of gl_blend to fix diagonal lines
//    glDisable(GL_BLEND);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glVertex3f(-width,  height,  0);
//  glEnd();

//  glBegin(GL_TRIANGLES);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glVertex3f(-width,  height,  0);
//  glEnd();
  glBegin(GL_QUADS);
  glVertex3f(-width, -height,0);
  glVertex3f( width, -height,0);
  glVertex3f( width,  height,0);
  glVertex3f(-width,  height,0);
  glEnd();

  glColor4i(r, g, b, 255);
//  glColor4f(r, g, b, 1.0);

  //senquack
//  glBegin(GL_LINE_LOOP);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glVertex3f(-width,  height,  0);
//  glEnd();
  //senquack - 1st try:
//  glBegin(GL_QUADS);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glVertex3f(-width,  height,  0);
//  glEnd();
  //senquack - 2nd try:

//  glBegin(GL_LINES);
//  glVertex3f(-width, -height,  0);
//  glVertex3f( width, -height,  0);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex3f( width, -height,  0);
//  glVertex3f( width,  height,  0);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex3f( width,  height,  0);
//  glVertex3f(-width,  height,  0);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex3f(-width,  height,  0);
//  glVertex3f(-width, -height,  0);
//  glEnd();

  //senquack - 3rd try:
//  glBegin(GL_LINES);
//  glVertex2f(-width, -height);
//  glVertex2f( width, -height);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f( width, -height);
//  glVertex2f( width,  height);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f( width,  height);
//  glVertex2f(-width,  height);
//  glEnd();

  //senquack -if I just leave this one enabled it STILL causes the vertical problem
//  glBegin(GL_LINES);
//  glVertex2f(-width,  height);
//  glVertex2f(-width, -height);
//  glEnd();

//  glBegin(GL_LINE_LOOP);
//  glVertex2f(-width, -height);
//  glVertex2f( width, -height);
//  glVertex2f( width,  height);
//  glVertex2f(-width,  height);
//  glVertex2f(-width, -height);
//  glEnd();

  glPopMatrix();
}

//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
//  glColor4i(r, g, b, a);
//  glBegin(GL_LINES);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x2, y2, z2);
//  glEnd();
//}
//senquack - tried tweaking this to fix hang:
//senquack - changing this back to 3D coordinates resulted in same screwing up of triangles elsewhere:
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
//  glColor4i(r, g, b,a);
//
//	//senquack- forcing this did not help:
////  glColor4i(255, 255, 255, 255);
//
//  //glColor4i(r, g, b, a);
////  glBegin(GL_LINES);
////  glVertex2f(x1, y1);
////  glVertex2f(x2, y2);
////  glEnd();
//  glBegin(GL_LINE_LOOP);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x2, y2, z2);
//  glEnd();
//}
//senquack - nanoGL does not support line drawing, must call OpenGLES directly:
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
////  glColor4i(r, g, b,a);
////
////	//senquack- forcing this did not help:
//////  glColor4i(255, 255, 255, 255);
////
////  //glColor4i(r, g, b, a);
//////  glBegin(GL_LINES);
//////  glVertex2f(x1, y1);
//////  glVertex2f(x2, y2);
//////  glEnd();
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
//
////code from net (2d:)
////const GLfloat line[] = {
////-0.5f, -0.5f, //point A
////0.5f, -0.5f, //point B
////};
////
////glColor4f(0.0f,1.0f,0.0f,1.0f); //line color
////glVertexPointer(2, GL_FLOAT, 0, line);
////glEnableClientState(GL_VERTEX_ARRAY);
////
////glDrawArrays(GL_LINES, 0, 2);
//	GLfloat line[6];
//	line[0] = x1; line[1] = y1; line[2] = z1;
//	line[3] = x2; line[4] = y2; line[5] = z2;
//	
//	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
//// temporary experiment:
//	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
//	glVertexPointer(3, GL_FLOAT, 0, line);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	
//	glDrawArrays(GL_LINES, 0, 2);
//	glDisableClientState(GL_VERTEX_ARRAY);
//}
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
////  glColor4i(r, g, b,a);
////
////	//senquack- forcing this did not help:
//////  glColor4i(255, 255, 255, 255);
////
////  //glColor4i(r, g, b, a);
//////  glBegin(GL_LINES);
//////  glVertex2f(x1, y1);
//////  glVertex2f(x2, y2);
//////  glEnd();
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
//
////code from net (2d:)
////const GLfloat line[] = {
////-0.5f, -0.5f, //point A
////0.5f, -0.5f, //point B
////};
////
////glColor4f(0.0f,1.0f,0.0f,1.0f); //line color
////glVertexPointer(2, GL_FLOAT, 0, line);
////glEnableClientState(GL_VERTEX_ARRAY);
////
////glDrawArrays(GL_LINES, 0, 2);
//	GLfloat line[6];
//	line[0] = x1; line[1] = y1; line[2] = z1;
//	line[3] = x2; line[4] = y2; line[5] = z2;
//	
//	glEnable(GL_BLEND);
//	glEnable(GL_LINE_SMOOTH);
//
//	glLineWidth(2.0f);
//
//	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
//// temporary experiment:
//	glColor4f_direct(1.0f, 1.0f, 1.0f, 1.0f);
//	glVertexPointer(3, GL_FLOAT, 0, line);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	
//	glDrawArrays(GL_LINES, 0, 2);
//
//	glDisableClientState(GL_VERTEX_ARRAY);
//}
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
////  glColor4i(r, g, b,a);
////
////	//senquack- forcing this did not help:
//////  glColor4i(255, 255, 255, 255);
////
////  //glColor4i(r, g, b, a);
//////  glBegin(GL_LINES);
//////  glVertex2f(x1, y1);
//////  glVertex2f(x2, y2);
//////  glEnd();
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
//
////code from net (2d:)
////const GLfloat line[] = {
////-0.5f, -0.5f, //point A
////0.5f, -0.5f, //point B
////};
////
////glColor4f(0.0f,1.0f,0.0f,1.0f); //line color
////glVertexPointer(2, GL_FLOAT, 0, line);
////glEnableClientState(GL_VERTEX_ARRAY);
////
////glDrawArrays(GL_LINES, 0, 2);
//	GLfloat line[12];
//	line[0] = x1; line[1] = y1; line[2] = z1;
//	line[3] = x1+10.0; line[4] = y1+10.0; line[5] = z1+10.0;
//	line[6] = x2; line[7] = y2; line[8] = z2;
//	line[9] = x2+10.0; line[10] = y2+10.0; line[11] = z2+10.0;
//	
//
////	GLfloat colors[16] = {1.0};
//
//	GLubyte colors[16] = {255, 255, 255, 255,
//									255,255,255,255,
//									255,255,255,255,
//									255,255,255,255};
////senquack - note: this doesn't work, you must specify all 16 manually
////	GLubyte colors[16] = {255};
//
////	colors[0] = colors[3] = (float)r / 255.0; 
////	colors[1] = colors[4] = (float)g / 255.0; 
////	colors[2] = colors[5] = (float)b / 255.0;
////	colors[0] = colors[4] = 1.0;
////	colors[1] = colors[5] = 1.0;
////	colors[2] = colors[6] = 1.0;
////	colors[3] = colors[7] = 1.0;
//	
//	glEnable(GL_BLEND);
//	glEnable(GL_LINE_SMOOTH);
//	glLineWidth(2.0f);
////	glLineWidth(1.0f);
//
//	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
//// temporary experiment:
////	glColor4f_direct(1.0f, 1.0f, 1.0f, 1.0f);
//	glVertexPointer(3, GL_FLOAT, 0, line);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
//	glEnableClientState(GL_COLOR_ARRAY);
//	
//	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
//
////	glDisableClientState(GL_COLOR_ARRAY);
////	glDisableClientState(GL_VERTEX_ARRAY);
//}
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
////  glColor4i(r, g, b,a);
////
////	//senquack- forcing this did not help:
//////  glColor4i(255, 255, 255, 255);
////
////  //glColor4i(r, g, b, a);
//////  glBegin(GL_LINES);
//////  glVertex2f(x1, y1);
//////  glVertex2f(x2, y2);
//////  glEnd();
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
//
////code from net (2d:)
////const GLfloat line[] = {
////-0.5f, -0.5f, //point A
////0.5f, -0.5f, //point B
////};
////
////glColor4f(0.0f,1.0f,0.0f,1.0f); //line color
////glVertexPointer(2, GL_FLOAT, 0, line);
////glEnableClientState(GL_VERTEX_ARRAY);
////
////glDrawArrays(GL_LINES, 0, 2);
//	GLfloat line[6];
//	line[0] = x1; line[1] = y1; line[2] = z1;
//	line[3] = x2; line[4] = y2; line[5] = z2;
//
////	GLfloat colors[8];
//////	colors[0] = colors[3] = (float)r / 255.0; 
//////	colors[1] = colors[4] = (float)g / 255.0; 
//////	colors[2] = colors[5] = (float)b / 255.0;
////	colors[0] = colors[4] = 1.0;
////	colors[1] = colors[5] = 1.0;
////	colors[2] = colors[6] = 1.0;
////	colors[3] = colors[7] = 1.0;
//	GLuint colors[8];
////	colors[0] = colors[3] = (float)r / 255.0; 
////	colors[1] = colors[4] = (float)g / 255.0; 
////	colors[2] = colors[5] = (float)b / 255.0;
//	colors[0] = colors[4] = 255;
//	colors[1] = colors[5] = 255;
//	colors[2] = colors[6] = 255;
//	colors[3] = colors[7] = 255;
//	
////	glDisable(GL_BLEND);
////	glDisable(GL_LINE_SMOOTH);
////	glLineWidth(2.0f);
//	glLineWidth(1.0f);
//
//	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
//// temporary experiment:
////	glColor4f_direct(1.0f, 1.0f, 1.0f, 1.0f);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	glEnableClientState(GL_COLOR_ARRAY);
////	glVertexPointer(3, GL_FLOAT, 0, line);
//	glVertexPointer(3, GL_FLOAT, 3 * sizeof(GLfloat), line);
////	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
//	glColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(GLuint), colors);
//	
//	glDrawArrays(GL_LINES, 0, 2);
//
////	glDisableClientState(GL_COLOR_ARRAY);
////	glDisableClientState(GL_VERTEX_ARRAY);
//}
//void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
//	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
////  glColor4i(r, g, b,a);
////
////	//senquack- forcing this did not help:
//////  glColor4i(255, 255, 255, 255);
////
////  //glColor4i(r, g, b, a);
//////  glBegin(GL_LINES);
//////  glVertex2f(x1, y1);
//////  glVertex2f(x2, y2);
//////  glEnd();
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
//
////code from net (2d:)
////const GLfloat line[] = {
////-0.5f, -0.5f, //point A
////0.5f, -0.5f, //point B
////};
////
////glColor4f(0.0f,1.0f,0.0f,1.0f); //line color
////glVertexPointer(2, GL_FLOAT, 0, line);
////glEnableClientState(GL_VERTEX_ARRAY);
////
////glDrawArrays(GL_LINES, 0, 2);
////	GLfloat line[6];
////	line[0] = x1; line[1] = y1; line[2] = z1;
////	line[3] = x2; line[4] = y2; line[5] = z2;
//	GLfixed line[6];
//	line[0] = f2x(x1); line[1] = f2x(y1); line[2] = f2x(z1);
//	line[3] = f2x(x2); line[4] = f2x(y2); line[5] = f2x(z2);
//	
//
////	GLfloat colors[16] = {1.0};
//
//	GLubyte colors[8] = {255, 255, 255, 255,
//									255,255,255,255};
////senquack - note: this doesn't work, you must specify all 16 manually
////	GLubyte colors[16] = {255};
//
////	colors[0] = colors[3] = (float)r / 255.0; 
////	colors[1] = colors[4] = (float)g / 255.0; 
////	colors[2] = colors[5] = (float)b / 255.0;
////	colors[0] = colors[4] = 1.0;
////	colors[1] = colors[5] = 1.0;
////	colors[2] = colors[6] = 1.0;
////	colors[3] = colors[7] = 1.0;
//	
////	glEnable(GL_BLEND);
//	glDisable(GL_LINE_SMOOTH);
////	glLineWidth(2.0f);
////	glLineWidth(1.0f);
//
//	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
//// temporary experiment:
////	glColor4f_direct(1.0f, 1.0f, 1.0f, 1.0f);
//
//  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
//
//	glVertexPointer(3, GL_FIXED, 0, line);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
//	glEnableClientState(GL_COLOR_ARRAY);
//	
//	glDrawArrays(GL_LINES, 0, 2);
//
////	glDisableClientState(GL_COLOR_ARRAY);
////	glDisableClientState(GL_VERTEX_ARRAY);
//}
void drawLine(GLfloat x1, GLfloat y1, GLfloat z1,
	      GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a) {
//senquack - note: it appears Wiz's opengl supports line drawing with either fixed or float vertices, your choice:
	GLfloat line[6];
	line[0] = x1; line[1] = y1; line[2] = z1;
	line[3] = x2; line[4] = y2; line[5] = z2;
//	GLfixed line[6];
//	line[0] = f2x(x1); line[1] = f2x(y1); line[2] = f2x(z1);
//	line[3] = f2x(x2); line[4] = f2x(y2); line[5] = f2x(z2);
	
	GLubyte colors[8] = {r, g, b, a, r, g, b, a};

//	glVertexPointer(3, GL_FIXED, 0, line);
	glVertexPointer(3, GL_FLOAT, 0, line);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
	glEnableClientState(GL_COLOR_ARRAY);
	
	glDrawArrays(GL_LINES, 0, 2);

// senquack - note - not necessary to turn these off here it seems:
//	glDisableClientState(GL_COLOR_ARRAY);
//	glDisableClientState(GL_VERTEX_ARRAY);
}


//void drawLinePart(GLfloat x1, GLfloat y1, GLfloat z1,
//		  GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int len) {
//  glColor4i(r, g, b,a);
//  glBegin(GL_LINES);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x1+(x2-x1)*len/256, y1+(y2-y1)*len/256, z1+(z2-z1)*len/256);
//  glEnd();
//}
//senquack - tried tweaking this to fix hang:
//void drawLinePart(GLfloat x1, GLfloat y1, GLfloat z1,
//		  GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int len) {
//  glColor4i(r, g, b, a);
////  glColor4i(255, 255, 255, 255);
////  glBegin(GL_LINES);
////  glVertex2f(x1, y1);
////  glVertex2f(x1+(x2-x1)*len/256, y1+(y2-y1)*len/256);
////  glEnd();
//  glBegin(GL_LINE_LOOP);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x1+(x2-x1)*len/256, y1+(y2-y1)*len/256, z1+(z2-z1)*len/256);
//  glEnd();
//}
////senquack - nanoGL does not support line drawing, must call OpenGLES directly:
//void drawLinePart(GLfloat x1, GLfloat y1, GLfloat z1,
//		  GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int len) {
//////  glColor4i(r, g, b, a);
////////  glColor4i(255, 255, 255, 255);
////////  glBegin(GL_LINES);
////////  glVertex2f(x1, y1);
////////  glVertex2f(x1+(x2-x1)*len/256, y1+(y2-y1)*len/256);
////////  glEnd();
//////  glBegin(GL_LINE_LOOP);
//////  glVertex3f(x1, y1, z1);
//////  glVertex3f(x1+(x2-x1)*len/256, y1+(y2-y1)*len/256, z1+(z2-z1)*len/256);
//////  glEnd();
////
////	GLfloat line[6];
////	line[0] = x1; line[1] = y1; line[2] = z1;
////	line[3] = x1+(x2-x1)*len/256; line[4] = y1+(y2-y1)*len/256; line[5] = z1+(z2-z1)*len/256;
////	
////	glDisable(GL_TEXTURE_2D);
////	glColor4f((float)r / 255.0, (float)g / 255.0, (float)b / 255.0, (float)a / 255.0);
////	glVertexPointer(3, GL_FLOAT, 0, line);
////	glEnableClientState(GL_VERTEX_ARRAY);
////	glDrawArrays(GL_LINES, 0, 2);
////	glDisableClientState(GL_VERTEX_ARRAY);
//}
//senquack - nanoGL does not support line drawing, must call OpenGLES directly:
void drawLinePart(GLfloat x1, GLfloat y1, GLfloat z1,
		  GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int len) {

	GLfloat line[6];
	line[0] = x1; line[1] = y1; line[2] = z1;
	line[3] = x1+(x2-x1)*len/256; line[4] = y1+(y2-y1)*len/256; line[5] = z1+(z2-z1)*len/256;
	
	GLubyte colors[8] = {r, g, b, a, r, g, b, a};

//	glVertexPointer(3, GL_FIXED, 0, line);
	glVertexPointer(3, GL_FLOAT, 0, line);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
	glEnableClientState(GL_COLOR_ARRAY);
	glDrawArrays(GL_LINES, 0, 2);
}

  //senquack - tried tweaking this to fix hang:
//senquack - try changing this to LINE_LOOP to fix drawing problems:
//void drawRollLineAbs(GLfloat x1, GLfloat y1, GLfloat z1,
//		     GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int d1) {
//  glPushMatrix();
//  glRotatef((float)d1*360/1024, 0, 0, 1);
//  glColor4i(r, g, b, a);
//  glBegin(GL_LINES);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x2, y2, z2);
//  glEnd();
//  glPopMatrix();
//}
//void drawRollLineAbs(GLfloat x1, GLfloat y1, GLfloat z1,
//		     GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int d1) {
////  glPushMatrix();
////  glRotatef((float)d1*360/1024, 0, 0, 1);
////   
////  glColor4i(r, g, b, a);
////  glBegin(GL_LINES);
////  glVertex3f(x1, y1, z1);
////  glVertex3f(x2, y2, z2);
////  glEnd();
////
////  glPopMatrix();
//}
void drawRollLineAbs(GLfloat x1, GLfloat y1, GLfloat z1,
		     GLfloat x2, GLfloat y2, GLfloat z2, int r, int g, int b, int a, int d1) {
  glPushMatrix();
  glRotatef((float)d1*360/1024, 0, 0, 1);

	GLfloat line[6];
	line[0] = x1; line[1] = y1; line[2] = z1;
	line[3] = x2; line[4] = y2; line[5] = z2;
//	GLfixed line[6];
//	line[0] = f2x(x1); line[1] = f2x(y1); line[2] = f2x(z1);
//	line[3] = f2x(x2); line[4] = f2x(y2); line[5] = f2x(z2);
	
	GLubyte colors[8] = {r, g, b, a, r, g, b, a};

//	glVertexPointer(3, GL_FIXED, 0, line);
	glVertexPointer(3, GL_FLOAT, 0, line);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
	glEnableClientState(GL_COLOR_ARRAY);
	
	glDrawArrays(GL_LINES, 0, 2);
  glPopMatrix();
}


//senquack - new - changing all TRIANGLE_FANs with only three vertices to TRIANGLES
  //senquack - tried tweaking this to fix hang:
//void drawTestPoly()
//{
//  static float x = 0.0f;
//  if (x > 32)
//     x = 0.0f;
//  x++;
//     
//  //printf("drawing poly\n"); fflush(stdout);
//  glBegin(GL_TRIANGLE_FAN);
//  glColor4i(255, 0, 0, 255);
//  glVertex3f(x, 5.0f, 0.0f);
//  glColor4i(0, 255, 0, 255);
//  glVertex3f(0.0f, -5.0f, 0.0f);
//  glColor4i(0, 0, 255, 255);
//  glVertex3f(-2.0f, 5.0f, 0.0f);
//  glEnd();
//  //printf("done drawing poly\n"); fflush(stdout);
//
//}
void drawTestPoly()
{
  static float x = 0.0f;
//  if (x > 32)
//     x = 0.0f;
//  x++;
     
  //printf("drawing poly\n"); fflush(stdout);
  //senquack:
//  glBegin(GL_TRIANGLE_FAN);
  glBegin(GL_TRIANGLES);
  glColor4i(255, 0, 0, 255);
  glVertex3f(x, 5.0f, 0.0f);
  glColor4i(0, 255, 0, 255);
  glVertex3f(0.0f, -5.0f, 0.0f);
  glColor4i(0, 0, 255, 255);
  glVertex3f(-2.0f, 5.0f, 0.0f);
  glEnd();
  //printf("done drawing poly\n"); fflush(stdout);

}

  //senquack - tried tweaking this to fix hang:
//void drawRollLine(GLfloat x, GLfloat y, GLfloat z, GLfloat width,
//		  int r, int g, int b, int a, int d1, int d2) {
//  glPushMatrix();
//  glTranslatef(x, y, z);
//  glRotatef((float)d1*360/1024, 0, 0, 1);
//  glRotatef((float)d2*360/1024, 1, 0, 0);
//  glColor4i(r, g, b, a);
//  glBegin(GL_LINES);
//  glVertex3f(0, -width, 0);
//  glVertex3f(0,  width, 0);
//  glEnd();
//  glPopMatrix();
//}
//void drawRollLine(GLfloat x, GLfloat y, GLfloat z, GLfloat width,
//		  int r, int g, int b, int a, int d1, int d2) {
////  glPushMatrix();
////  glTranslatef(x, y, z);
////  glRotatef((float)d1*360/1024, 0, 0, 1);
////  glRotatef((float)d2*360/1024, 1, 0, 0);
////  glColor4i(r, g, b, a);
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(0, -width, 0);
////  glVertex3f(0,  width, 0);
////  glEnd();
////  glPopMatrix();
//}
void drawRollLine(GLfloat x, GLfloat y, GLfloat z, GLfloat width,
		  int r, int g, int b, int a, int d1, int d2) {
  glPushMatrix();
  glTranslatef(x, y, z);
  glRotatef((float)d1*360/1024, 0, 0, 1);
  glRotatef((float)d2*360/1024, 1, 0, 0);

	GLfloat line[6];
	line[0] = 0; line[1] = -width; line[2] = 0;
	line[3] = 0; line[4] = width; line[5] = 0;
	
	GLubyte colors[8] = {r, g, b, a, r, g, b, a};

	glVertexPointer(3, GL_FLOAT, 0, line);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
	glEnableClientState(GL_COLOR_ARRAY);
	
	glDrawArrays(GL_LINES, 0, 2);
  glPopMatrix();
}

// 2/11 - new efforts to convert all triangle fans to something else:
//senquack - further attempts 2/11/2010:
  //senquack - tried tweaking this to fix hang:
//void drawSquare(GLfloat x1, GLfloat y1, GLfloat z1,
//		GLfloat x2, GLfloat y2, GLfloat z2,
//		GLfloat x3, GLfloat y3, GLfloat z3,
//		GLfloat x4, GLfloat y4, GLfloat z4,
//		int r, int g, int b) {
//  glColor4i(r, g, b, 64);
//
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x2, y2, z2);
//  glVertex3f(x3, y3, z3);
//  glVertex3f(x4, y4, z4);
//  glEnd();
//}
void drawSquare(GLfloat x1, GLfloat y1, GLfloat z1,
		GLfloat x2, GLfloat y2, GLfloat z2,
		GLfloat x3, GLfloat y3, GLfloat z3,
		GLfloat x4, GLfloat y4, GLfloat z4,
		int r, int g, int b) {
  glColor4i(r, g, b, 64);

  glBegin(GL_TRIANGLE_FAN);
  glVertex3f(x1, y1, z1);
  glVertex3f(x2, y2, z2);
  glVertex3f(x3, y3, z3);
  glVertex3f(x4, y4, z4);
  glEnd();

//  // senquack 2/11 converting this to triangles 
//  glBegin(GL_TRIANGLES);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x2, y2, z2);
//  glVertex3f(x3, y3, z3);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//  glVertex3f(x1, y1, z1);
//  glVertex3f(x3, y3, z3);
//  glVertex3f(x4, y4, z4);
//  glEnd();
}

//senquack - this was already commented out:
void drawStar(int f, GLfloat x, GLfloat y, GLfloat z, int r, int g, int b, float size) {
 /* glEnable(GL_TEXTURE_2D);
  if ( f ) {
    glBindTexture(GL_TEXTURE_2D, starTexture);
  } else {
    glBindTexture(GL_TEXTURE_2D, smokeTexture);
  }
  */
  /*
  //printf("drawing star...\n"); fflush(stdout);
  glColor4i(r, g, b, 255);
  glPushMatrix();
  glTranslatef(x, y, z);
  glRotatef(rand()%360, 0.0f, 0.0f, 1.0f);
  glBegin(GL_TRIANGLE_FAN);
  glTexCoord2f(0.0f, 1.0f);
  glVertex3f(-size, -size,  0);
  glTexCoord2f(1.0f, 1.0f);
  glVertex3f( size, -size,  0);
  glTexCoord2f(1.0f, 0.0f);
  glVertex3f( size,  size,  0);
  glTexCoord2f(0.0f, 0.0f);
  glVertex3f(-size,  size,  0);
  glEnd();
  glPopMatrix();
  glDisable(GL_TEXTURE_2D);
  */
}

#define LASER_ALPHA 100
#define LASER_LINE_ALPHA 50
#define LASER_LINE_ROLL_SPEED 17
#define LASER_LINE_UP_SPEED 16

//senquack - experimenting with speed improvements
//void drawLaser(GLfloat x, GLfloat y, GLfloat width, GLfloat height,
//	       int cc1, int cc2, int cc3, int cc4, int cnt, int type) {
//  int i, d;
//  float gx, gy;
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex3f(x-width, y, 0);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex3f(x, y, 0);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x-width, y+height, 0);
//  glEnd();
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex3f(x+width, y, 0);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex3f(x, y, 0);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x+width, y+height, 0);
//  glEnd();
//  if ( type == 2 ) return;
//  glColor4i(80, 240, 80, LASER_LINE_ALPHA);
//  glBegin(GL_LINES);
//  d = (cnt*LASER_LINE_ROLL_SPEED)&(512/4-1);
//  for ( i=0 ; i<4 ; i++, d+=(512/4) ) {
//    d &= 1023;
//    gx = x + width*sctbl[d+256]/256.0f;
//    if ( type == 1 ) {
//      glVertex3f(gx, y, 0);
//    } else {
//      glVertex3f(x, y, 0);
//    }
//    glVertex3f(gx, y+height, 0);
//  }
//  if ( type == 0 ) {
//    glEnd();
//    return;
//  }
//  gy = y + (height/4/LASER_LINE_UP_SPEED) * (cnt&(LASER_LINE_UP_SPEED-1));
//  for ( i=0 ; i<4 ; i++, gy+=height/4 ) {
//    glVertex3f(x-width, gy, 0);
//    glVertex3f(x+width, gy, 0);
//  }
//  glEnd();
//}
//senquack - stripped-down triangle version:
void drawLaser(GLfloat x, GLfloat y, GLfloat width, GLfloat height,
	       int cc1, int cc2, int cc3, int cc4, int cnt, int type) {
  int i, d;
  float gx, gy;

  //senquack - original left-side code, modifying to match right-side code that had to be changed below:
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex3f(x-width, y, 0);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex3f(x, y, 0);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x-width, y+height, 0);
//  glEnd();
//senquack - new - changing all TRIANGLE_FANs with only three vertices to TRIANGLES
//  glBegin(GL_TRIANGLE_FAN);
//  glBegin(GL_TRIANGLES);
////  if ( type != 0 ) {
////    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
////    glVertex3f(x-width, y, 0);
////  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex3f(x, y, 0);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x-width, y+height, 0);
//  glEnd();
//  glEnd();	// senquack - merging this triangle and the one below

  //senquack - this is the code for the right side that has the jerky bottom-right corner:
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex3f(x+width, y, 0);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex3f(x, y, 0);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x+width, y+height, 0);
//  glEnd();
//senquack - new - changing all TRIANGLE_FANs with only three vertices to TRIANGLES
//  glBegin(GL_TRIANGLE_FAN);
//  glBegin(GL_TRIANGLES); // senquack - merging this triangle and the one above

//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex3f(x+width, y, 0);
//  }
  glBegin(GL_TRIANGLE_FAN);
  glColor4i(cc2, 255, cc2, LASER_ALPHA);
  glVertex2f(x, y);
  glColor4i(cc4, 255, cc4, LASER_ALPHA);
  glVertex2f(x, y+height);
  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
  glVertex2f(x-width, y+height);
  glColor4i(cc2, 255, cc2, LASER_ALPHA);
  glVertex2f(x, y);
  glColor4i(cc4, 255, cc4, LASER_ALPHA);
  glVertex2f(x, y+height);
  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
  glVertex2f(x+width, y+height);
  glEnd();



//  glVertex3f(x, y, 0);
////  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex3f(x, y+height, 0);
////  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex3f(x+width, y+height, 0);

  //senquack - simply disabling this code reduces a lot of the weird assymetric line drawing
  //			and also still darned cool and clean.  Should provide a much-needed speedup too!
//  if ( type == 2 ) return;
//  glColor4i(80, 240, 80, LASER_LINE_ALPHA);
//  glBegin(GL_LINES);
//  d = (cnt*LASER_LINE_ROLL_SPEED)&(512/4-1);
//  for ( i=0 ; i<4 ; i++, d+=(512/4) ) {
//    d &= 1023;
//    gx = x + width*sctbl[d+256]/256.0f;
//    if ( type == 1 ) {
//      glVertex3f(gx, y, 0);
//    } else {
//      glVertex3f(x, y, 0);
//    }
//    glVertex3f(gx, y+height, 0);
//  }
//  if ( type == 0 ) {
//    glEnd();
//    return;
//  }
//  gy = y + (height/4/LASER_LINE_UP_SPEED) * (cnt&(LASER_LINE_UP_SPEED-1));
//  for ( i=0 ; i<4 ; i++, gy+=height/4 ) {
//    glVertex3f(x-width, gy, 0);
//    glVertex3f(x+width, gy, 0);
//  }
//  glEnd();
}
//senquack - nicer, fuller, slower version:
//void drawLaser(GLfloat x, GLfloat y, GLfloat width, GLfloat height,
//	       int cc1, int cc2, int cc3, int cc4, int cnt, int type) {
//  int i, d;
//  float gx, gy;
//
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex2f(x-width, y);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex2f(x, y);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex2f(x, y+height);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex2f(x-width, y+height);
//  glEnd();
//
//
//  glBegin(GL_TRIANGLE_FAN);
//  if ( type != 0 ) {
//    glColor4i(cc1, cc1, cc1, LASER_ALPHA);
//    glVertex2f(x+width, y);
//  }
//  glColor4i(cc2, 255, cc2, LASER_ALPHA);
//  glVertex2f(x, y);
//  glColor4i(cc4, 255, cc4, LASER_ALPHA);
//  glVertex2f(x, y+height);
//  glColor4i(cc3, cc3, cc3, LASER_ALPHA);
//  glVertex2f(x+width, y+height);
//  glEnd();
//  //senquack - no need for these:
////  if ( type == 2 ) return;
////  glColor4i(80, 240, 80, LASER_LINE_ALPHA);
////  glBegin(GL_LINES);
////  d = (cnt*LASER_LINE_ROLL_SPEED)&(512/4-1);
////  for ( i=0 ; i<4 ; i++, d+=(512/4) ) {
////    d &= 1023;
////    gx = x + width*sctbl[d+256]/256.0f;
////    if ( type == 1 ) {
////      glVertex3f(gx, y, 0);
////    } else {
////      glVertex3f(x, y, 0);
////    }
////    glVertex3f(gx, y+height, 0);
////  }
////  if ( type == 0 ) {
////    glEnd();
////    return;
////  }
////  gy = y + (height/4/LASER_LINE_UP_SPEED) * (cnt&(LASER_LINE_UP_SPEED-1));
////  for ( i=0 ; i<4 ; i++, gy+=height/4 ) {
////    glVertex3f(x-width, gy, 0);
////    glVertex3f(x+width, gy, 0);
////  }
////  glEnd();
//}

#define SHAPE_POINT_SIZE 0.05f
#define SHAPE_BASE_COLOR_R 250
#define SHAPE_BASE_COLOR_G 240
#define SHAPE_BASE_COLOR_B 180

#define CORE_HEIGHT 0.2f
#define CORE_RING_SIZE 0.6f

#define SHAPE_POINT_SIZE_L 0.07f

static void drawRing(GLfloat x, GLfloat y, int d1, int d2, int r, int g, int b) {
  int i, d;
  float x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;
  glPushMatrix();
  glTranslatef(x, y, 0);
  glRotatef((float)d1*360/1024, 0, 0, 1);
  glRotatef((float)d2*360/1024, 1, 0, 0);
  glColor4i(r, g, b, 255);
  x1 = x2 = 0;
  y1 = y4 =  CORE_HEIGHT/2;
  y2 = y3 = -CORE_HEIGHT/2;
  z1 = z2 = CORE_RING_SIZE;
  for ( i=0,d=0 ; i<8 ; i++ ) {
    d+=(1024/8); d &= 1023;
    x3 = x4 = sctbl[d+256]*CORE_RING_SIZE/256;
    z3 = z4 = sctbl[d]    *CORE_RING_SIZE/256;
    drawSquare(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, r, g, b);
    x1 = x3; y1 = y3; z1 = z3;
    x2 = x4; y2 = y4; z2 = z4;
  }
  glPopMatrix();
}

//senquack - 2/11 experiment:
//void drawCore(GLfloat x, GLfloat y, int cnt, int r, int g, int b) {
//  int i;
//  float cy;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(r, g, b, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
//  glPopMatrix();
//  cy = y - CORE_HEIGHT*2.5f;
//  for ( i=0 ; i<4 ; i++, cy+=CORE_HEIGHT ) {
//    drawRing(x, cy, (cnt*(4+i))&1023, (sctbl[(cnt*(5+i))&1023]/4)&1023, r, g, b);
//  }
//}
void drawCore(GLfloat x, GLfloat y, int cnt, int r, int g, int b) {
  int i;
  float cy;
  glPushMatrix();
  glTranslatef(x, y, 0);
  glColor4i(r, g, b, 255);

//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L);
  glVertex2f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L);
  glVertex2f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L);
  glVertex2f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L);
  glEnd();

  glPopMatrix();
  cy = y - CORE_HEIGHT*2.5f;
  for ( i=0 ; i<4 ; i++, cy+=CORE_HEIGHT ) {
    drawRing(x, cy, (cnt*(4+i))&1023, (sctbl[(cnt*(5+i))&1023]/4)&1023, r, g, b);
  }
}

#define SHIP_DRUM_R 0.4f
#define SHIP_DRUM_WIDTH 0.05f
#define SHIP_DRUM_HEIGHT 0.35f

//senquack - one of the causes of freezing is the drawing of the rotating "drum" in this function
//					and the way I found to fix it is changing GL_LINE_LOOP to GL_QUADS:
//void drawShipShape(GLfloat x, GLfloat y, float d, int inv) {
//  int i;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(255, 100, 100, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
//  if ( inv ) {
//    glPopMatrix();
//    return;
//  }
//  glRotatef(d, 0, 1, 0);
//    glColor4i(120, 220, 100, 150);
//    /*if ( mode == IKA_MODE ) {
//    glColor4i(180, 200, 160, 150);
//  } else {
//    glColor4i(120, 220, 100, 150);
//    }*/
//  for ( i=0 ; i<8 ; i++ ) {
//    glRotatef(45, 0, 1, 0);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f(-SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glEnd();
//  }
//  glPopMatrix();
//}
//senquack - 2nd try:
//void drawShipShape(GLfloat x, GLfloat y, float d, int inv) {
//  int i;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(255, 100, 100, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
//  if ( inv ) {
//    glPopMatrix();
//    return;
//  }
//  glRotatef(d, 0, 1, 0);
//    glColor4i(120, 220, 100, 150);
//    /*if ( mode == IKA_MODE ) {
//    glColor4i(180, 200, 160, 150);
//  } else {
//    glColor4i(120, 220, 100, 150);
//    }*/
//  for ( i=0 ; i<8 ; i++ ) {
//    glRotatef(45, 0, 1, 0);
//	 //senquack - freezing fix:
////    glBegin(GL_LINE_LOOP);
//    glBegin(GL_QUADS);
//    glVertex3f(-SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f(-SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glEnd();
//  }
//  glPopMatrix();
//}
//senquack - 3rd try:
void drawShipShape(GLfloat x, GLfloat y, float d, int inv) {
  int i;
  glPushMatrix();
  glTranslatef(x, y, 0);
  glColor4i(255, 100, 100, 255);

  //senquack
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L,  0);
//  glVertex3f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glVertex3f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L,  0);
//  glEnd();
  glBegin(GL_QUADS);
  glVertex2f(-SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L);
  glVertex2f( SHAPE_POINT_SIZE_L, -SHAPE_POINT_SIZE_L);
  glVertex2f( SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L);
  glVertex2f(-SHAPE_POINT_SIZE_L,  SHAPE_POINT_SIZE_L);
  glEnd();

  if ( inv ) {
    glPopMatrix();
    return;
  }
  glRotatef(d, 0, 1, 0);
    glColor4i(120, 220, 100, 150);
    /*if ( mode == IKA_MODE ) {
    glColor4i(180, 200, 160, 150);
  } else {
    glColor4i(120, 220, 100, 150);
    }*/
  for ( i=0 ; i<8 ; i++ ) {
    glRotatef(45, 0, 1, 0);
	 //senquack - freezing fix:
//    glBegin(GL_LINE_LOOP);
//    glBegin(GL_QUADS);

	 //senquack - disable for now
//    glBegin(GL_LINES);
//    glVertex3f(-SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex3f( SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f( SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex3f( SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f(-SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex3f(-SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glVertex3f(-SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
//    glEnd();
    glBegin(GL_QUADS);
    glVertex3f(-SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
    glVertex3f( SHIP_DRUM_WIDTH, -SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
    glVertex3f( SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
    glVertex3f(-SHIP_DRUM_WIDTH,  SHIP_DRUM_HEIGHT, SHIP_DRUM_R);
    glEnd();
  }
  glPopMatrix();
}

//senquack - converting to line strip for speed
void drawBomb(GLfloat x, GLfloat y, GLfloat width, int cnt) {
  int i, d, od, c;
  GLfloat x1, y1, x2, y2;
  d = cnt*48; d &= 1023;
  c = 4+(cnt>>3); if ( c > 16 ) c = 16;
  od = 1024/c;
  x1 = (sctbl[d]    *width)/256 + x;
  y1 = (sctbl[d+256]*width)/256 + y;
  for ( i=0 ; i<c ; i++ ) {
    d += od; d &= 1023;
    x2 = (sctbl[d]    *width)/256 + x;
    y2 = (sctbl[d+256]*width)/256 + y;
    drawLine(x1, y1, 0, x2, y2, 0, 255, 255, 255, 255);
    x1 = x2; y1 = y2;
  }
}
//void drawBomb(GLfloat x, GLfloat y, GLfloat width, int cnt) {
//  int i, d, od, c;
//  GLfloat x1, y1, x2, y2;
//  d = cnt*48; d &= 1023;
//  c = 4+(cnt>>3); if ( c > 16 ) c = 16;
//  od = 1024/c;
//  x1 = (sctbl[d]    *width)/256 + x;
//  y1 = (sctbl[d+256]*width)/256 + y;
//
//  glColor4i(255, 255, 255, 255);
//
//  //senquack - converted this to one giant line strip instead of multiple calls to drawLine for speedup
//  glBegin(GL_LINE_STRIP);
//  glVertex2f(x1,y1);
//  for ( i=0 ; i<c ; i++ ) {
//    d += od; d &= 1023;
//    x2 = (sctbl[d]    *width)/256 + x;
//    y2 = (sctbl[d+256]*width)/256 + y;
////    drawLine(x1, y1, 0, x2, y2, 0, 255, 255, 255, 255);
//    glVertex2f(x2, y2);
//    x1 = x2; y1 = y2;
//  }
//  glEnd();
//}
////senquack - nanoGL does not support line drawing, must call OpenGLES directly:
//void drawBomb(GLfloat x, GLfloat y, GLfloat width, int cnt) {
////  int i, d, od, c;
////  GLfloat x1, y1, x2, y2;
////  d = cnt*48; d &= 1023;
////  c = 4+(cnt>>3); if ( c > 16 ) c = 16;
////  od = 1024/c;
////  x1 = (sctbl[d]    *width)/256 + x;
////  y1 = (sctbl[d+256]*width)/256 + y;
////
////  glColor4i(255, 255, 255, 255);
////
////  //senquack - converted this to one giant line strip instead of multiple calls to drawLine for speedup
////  glBegin(GL_LINE_STRIP);
////  glVertex2f(x1,y1);
////  for ( i=0 ; i<c ; i++ ) {
////    d += od; d &= 1023;
////    x2 = (sctbl[d]    *width)/256 + x;
////    y2 = (sctbl[d+256]*width)/256 + y;
//////    drawLine(x1, y1, 0, x2, y2, 0, 255, 255, 255, 255);
////    glVertex2f(x2, y2);
////    x1 = x2; y1 = y2;
////  }
////  glEnd();
//
//  int i, d, od, c;
//  GLfloat x1, y1, x2, y2;
//  d = cnt*48; d &= 1023;
//  c = 4+(cnt>>3); if ( c > 16 ) c = 16;
//  od = 1024/c;
//  x1 = (sctbl[d]    *width)/256 + x;
//  y1 = (sctbl[d+256]*width)/256 + y;
//
////  glColor4i(255, 255, 255, 255);
//  glColor4f(1.0, 1.0, 1.0, 1.0);
//
//  //senquack - converted this to one giant line strip instead of multiple calls to drawLine for speedup
////  glBegin(GL_LINE_STRIP);
//	GLfloat *lines = malloc(sizeof(GLfloat) * (c+1) * 2);
//
////  glVertex2f(x1,y1);
//	lines[0] = x1; lines[1] = y1;
//
//  for ( i=0 ; i<c ; i++ ) {
//    d += od; d &= 1023;
//    x2 = (sctbl[d]    *width)/256 + x;
//    y2 = (sctbl[d+256]*width)/256 + y;
////    drawLine(x1, y1, 0, x2, y2, 0, 255, 255, 255, 255);
////    glVertex2f(x2, y2);
//	lines[(i<<1) + 2] = x1; lines[(i<<1) + 3] = y2;	
//    x1 = x2; y1 = y2;
//  }
////  glEnd();
//
//	glDisable(GL_TEXTURE_2D);
//	glVertexPointer(2, GL_FLOAT, 0, lines);
//	glEnableClientState(GL_VERTEX_ARRAY);
//	
//	glDrawArrays(GL_LINE_STRIP, 0, c+1);
//	free(lines);
//	glDisableClientState(GL_VERTEX_ARRAY);
//}
//void drawBomb(GLfloat x, GLfloat y, GLfloat width, int cnt) {
//  int i, d, od, c;
//  GLfloat x1, y1, x2, y2;
//  d = cnt*48; d &= 1023;
//  c = 4+(cnt>>3); if ( c > 16 ) c = 16;
//  od = 1024/c;
//  x1 = (sctbl[d]    *width)/256 + x;
//  y1 = (sctbl[d+256]*width)/256 + y;
//  for ( i=0 ; i<c ; i++ ) {
//    d += od; d &= 1023;
//    x2 = (sctbl[d]    *width)/256 + x;
//    y2 = (sctbl[d+256]*width)/256 + y;
////    drawLine(x1, y1, 0, x2, y2, 0, 255, 255, 255, 255);
////	glColor4i(255,255,255,255);
////	glDisable(GL_BLEND);
////	glBegin(GL_TRIANGLES);
////	glVertex3f(x1,y1,0);
////	glVertex3f(x1+4,y1+4,0);
////	glVertex3f(x2,y2,0);
////	glBegin(GL_TRIANGLE_STRIP);
////	glVertex3f(x1,y1,0);
////	glVertex3f(x1+4.0,y1+4.0,0);
////	glVertex3f(x2,y2,0);
////	glVertex3f(x2+4.0,y2+4.0,0);
////	glEnd();
//	drawTestPoly();
//    x1 = x2; y1 = y2;
//  }
//}

//senquack - FURTHER NOTE: this "circle" is jittery and obviously buggy somehow
//senquack - NO IT STILL FREEZES WITHOUT THIS BUT IT TAKES A LOONG TIME
//senquack - this might be what is causing freezes in IKA mode:
//NOTE - still freezes but with this enabled the circle seems jerky and something is wrong
//void drawCircle(GLfloat x, GLfloat y, GLfloat width, int cnt,
//		int r1, int g1, int b1, int r2, int b2, int g2) {
//  int i, d;
//  GLfloat x1, y1, x2, y2;
//  if ( (cnt&1) == 0 ) {
//    glColor4i(r1, g1, b1, 64);
//  } else {
//    glColor4i(255, 255, 255, 64);
//  }
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(x, y, 0);
//  d = cnt*48; d &= 1023;
//  x1 = (sctbl[d]    *width)/256 + x;
//  y1 = (sctbl[d+256]*width)/256 + y;
//  glColor4i(r2, g2, b2, 150);
//  for ( i=0 ; i<16 ; i++ ) {
//    d += 64; d &= 1023;
//    x2 = (sctbl[d]    *width)/256 + x;
//    y2 = (sctbl[d+256]*width)/256 + y;
//    glVertex3f(x1, y1, 0);
//    glVertex3f(x2, y2, 0);
//    x1 = x2; y1 = y2;
//  }
//  glEnd();
//}
//senquack - converting to 2D below:
//void drawCircle(GLfloat x, GLfloat y, GLfloat width, int cnt,
//		int r1, int g1, int b1, int r2, int b2, int g2) {
//  int i, d;
//  GLfloat x1, y1, x2, y2;
//  if ( (cnt&1) == 0 ) {
//    glColor4i(r1, g1, b1, 64);
//  } else {
//    glColor4i(255, 255, 255, 64);
//  }
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(x, y, 0);
//  d = cnt*48; d &= 1023;
//  x1 = (sctbl[d]    *width)/256 + x;
//  y1 = (sctbl[d+256]*width)/256 + y;
//  glColor4i(r2, g2, b2, 150);
//  for ( i=0 ; i<16 ; i++ ) {
//    d += 64; d &= 1023;
//    x2 = (sctbl[d]    *width)/256 + x;
//    y2 = (sctbl[d+256]*width)/256 + y;
//    glVertex3f(x1, y1, 0);
//    glVertex3f(x2, y2, 0);
//    x1 = x2; y1 = y2;
//  }
//  glEnd();
//}
void drawCircle(GLfloat x, GLfloat y, GLfloat width, int cnt,
		int r1, int g1, int b1, int r2, int b2, int g2) {
  int i, d;
  GLfloat x1, y1, x2, y2;
  if ( (cnt&1) == 0 ) {
    glColor4i(r1, g1, b1, 64);
  } else {
    glColor4i(255, 255, 255, 64);
  }
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(x, y);
  d = cnt*48; d &= 1023;
  x1 = (sctbl[d]    *width)/256 + x;
  y1 = (sctbl[d+256]*width)/256 + y;
  glColor4i(r2, g2, b2, 150);
  for ( i=0 ; i<16 ; i++ ) {
    d += 64; d &= 1023;
    x2 = (sctbl[d]    *width)/256 + x;
    y2 = (sctbl[d+256]*width)/256 + y;
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    x1 = x2; y1 = y2;
  }
  glEnd();
}

//senquack - new - found inconsistencies here.. TRIANGLE_FAN called with only three vertices.. changing 
//void drawShape(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type,
//	       int r, int g, int b) {
//  GLfloat sz, sz2;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(r, g, b, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
//  switch ( type ) {
//  case 0:
//    sz = size/2;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glVertex3f( 0, size,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 150);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( 0, size,  0);
//    glEnd();
//    break;
//  case 1:
//    sz = size/2;
//    glRotatef((float)((cnt*23)&1023)*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    //glBegin(GL_LINE_LOOP); 
//    glBegin(GL_LINES);
//    glVertex3f(  0, -size,  0);
//    glVertex3f( sz,     0,  0);
//    glVertex3f(  0,  size,  0);
//    glVertex3f(-sz,     0,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 180);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(  0, -size,  0);
//    glVertex3f( sz,     0,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f(  0,  size,  0);
//    glVertex3f(-sz,     0,  0);
//    glEnd();
//    break;
//  case 2:
//    sz = size/4; sz2 = size/3*2;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    //glBegin(GL_LINE_LOOP);
//    glBegin(GL_LINES);
//    glVertex3f(-sz, -sz2,  0);
//    glVertex3f( sz, -sz2,  0);
//    glVertex3f( sz,  sz2,  0);
//    glVertex3f(-sz,  sz2,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 120);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz2,  0);
//    glVertex3f( sz, -sz2,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz, sz2,  0);
//    glVertex3f(-sz, sz2,  0);
//    glEnd();
//    break;
//  case 3:
//    sz = size/2;
//    glRotatef((float)((cnt*37)&1023)*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    //glBegin(GL_LINE_LOOP);
//    glBegin(GL_LINES);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(-sz,  sz,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 180);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(-sz,  sz,  0);
//    glEnd();
//    break;
//  case 4:
//    sz = size/2;
//    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    //glBegin(GL_LINE_LOOP);
//    glBegin(GL_LINES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 220);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
//    break;
//  case 5:
//    sz = size*2/3; sz2 = size/5;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_STRIP);
//    glVertex3f(-sz, -sz+sz2,  0);
//    glVertex3f( 0, sz+sz2,  0);
//    glVertex3f( sz, -sz+sz2,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 150);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz+sz2,  0);
//    glVertex3f( sz, -sz+sz2,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( 0, sz+sz2,  0);
//    glEnd();
//    break;
//  case 6:
//    sz = size/2;
//    glRotatef((float)((cnt*13)&1023)*360/1024, 0, 0, 1);
//    glDisable(GL_BLEND);
//    //glBegin(GL_LINE_LOOP);
//    glBegin(GL_LINES);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f(  0, -sz,  0);
//    glVertex3f( sz,   0,  0);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(  0,  sz,  0);
//    glVertex3f(-sz,   0,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 210);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f(  0, -sz,  0);
//    glVertex3f( sz,   0,  0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(  0,  sz,  0);
//    glVertex3f(-sz,   0,  0);
//    glEnd();
//    break;
//  }
//  glPopMatrix();
//}
//void drawShape(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type,
//	       int r, int g, int b) {
//  GLfloat sz, sz2;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(r, g, b, 255);
//
//  //senquack
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
//  //senquack - 2nd try:
////  glBegin(GL_TRIANGLES);
////  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
////  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
////  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
////  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
////  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
////  glEnd();
//  //senquack - 3rd try:
////  glBegin(GL_QUADS);
////  glVertex2f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
////  glVertex2f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
////  glVertex2f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
////  glVertex2f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
////  glEnd();
//
//
//  switch ( type ) {
//  case 0:
//    sz = size/2;
//    glRotatef((float)d*360/1024, 0, 0, 1);
////    glDisable(GL_BLEND);
//
//	 //senquack - no need for this:
////    glBegin(GL_LINE_LOOP);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f( sz, -sz,  0);
////    glVertex3f( 0, size,  0);
////    glVertex3f(-sz, -sz,  0);
////    glEnd();
//
//    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 150);
//	 //senquack - here is a inconsistency, changing this line to just GL_TRIANGLES since we have only 3 vertices
////    glBegin(GL_TRIANGLE_FAN);
//	 //senaquack - also converting to 2D:
////    glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f( sz, -sz,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( 0, size,  0);
////    glEnd();
//    glBegin(GL_TRIANGLES);
//    glVertex2f(-sz, -sz);
//    glVertex2f( sz, -sz);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( 0, size);
//    glEnd();
//    break;
//  case 1:
//    sz = size/2;
//    glRotatef((float)((cnt*23)&1023)*360/1024, 0, 0, 1);
//	 //senquack - no need for this
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_LOOP); 
////    glVertex2f(  0, -size);
////    glVertex2f( sz,     0);
////    glVertex2f(  0,  size);
////    glVertex2f(-sz,     0);
////    glVertex2f(  0, -size);
////    glEnd();
////    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 180);
//
//	//senquack - converting to 2D
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(  0, -size,  0);
////    glVertex3f( sz,     0,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f(  0,  size,  0);
////    glVertex3f(-sz,     0,  0);
////    glEnd();
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex2f(  0, -size);
//    glVertex2f( sz,     0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f(  0,  size);
//    glVertex2f(-sz,     0);
//    glEnd();
//
//    break;
//  case 2:
//    sz = size/4; sz2 = size/3*2;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//	 //senquack - no need for this
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_LOOP);
////    glVertex2f(-sz, -sz2);
////    glVertex2f( sz, -sz2);
////    glVertex2f( sz,  sz2);
////    glVertex2f(-sz,  sz2);
////    glVertex2f(-sz, -sz2);
////    glEnd();
////    glEnable(GL_BLEND);
//
//    glColor4i(r, g, b, 120);
//
//	 //senquack - converting to 2D
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz, -sz2,  0);
////    glVertex3f( sz, -sz2,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( sz, sz2,  0);
////    glVertex3f(-sz, sz2,  0);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex2f(-sz, -sz2);
//    glVertex2f( sz, -sz2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( sz, sz2);
//    glVertex2f(-sz, sz2);
//    break;
//  case 3:
//    sz = size/2;
//    glRotatef((float)((cnt*37)&1023)*360/1024, 0, 0, 1);
//	 //senquack - no need for this
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_LOOP);
////    glVertex2f(-sz, -sz);
////    glVertex2f( sz, -sz);
////    glVertex2f( sz,  sz);
////    glVertex2f(-sz,  sz);
////    glVertex2f(-sz, -sz);
////    glEnd();
////    glEnable(GL_BLEND);
//
//    glColor4i(r, g, b, 180);
//
//	 //senquack - converting to 2D:
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f( sz, -sz,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( sz,  sz,  0);
////    glVertex3f(-sz,  sz,  0);
////    glEnd();
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex2f(-sz, -sz);
//    glVertex2f( sz, -sz);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( sz,  sz);
//    glVertex2f(-sz,  sz);
//    glEnd();
//    break;
//  case 4:
//    sz = size/2;
//    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
//
//	 //senquack - no need for this
////    glBegin(GL_LINES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
//
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_LOOP);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
////    glVertex3f(-sz/2, -sz,  0);
////	 glEnd();
////    glEnable(GL_BLEND);
//
//
//    glColor4i(r, g, b, 220);
//
//	 //senquack - converting to 2D
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
////    glEnd();
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex2f(-sz/2, -sz);
//    glVertex2f( sz/2, -sz);
//    glVertex2f( sz,  -sz/2);
//    glVertex2f( sz,   sz/2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( sz/2,  sz);
//    glVertex2f(-sz/2,  sz);
//    glVertex2f(-sz,   sz/2);
//    glVertex2f(-sz,  -sz/2);
//    glEnd();
//
//
////    glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////	  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////  glEnd();
////
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glVertex3f( sz/2,  sz,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
////    glEnd();
//    break;
//  case 5:
//    sz = size*2/3; sz2 = size/5;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//// 2/11 - new efforts to convert all triangle fans and line loops to something else:
//	 //senquack
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_STRIP);
////    glVertex3f(-sz, -sz+sz2,  0);
////    glVertex3f( 0, sz+sz2,  0);
////    glVertex3f( sz, -sz+sz2,  0);
////    glEnd();
//
//	 //senquack - no need for this
////    glDisable(GL_BLEND);
////    glBegin(GL_LINE_LOOP);
////    glVertex2f(-sz, -sz+sz2);
////    glVertex2f( 0, sz+sz2);
////    glVertex2f( sz, -sz+sz2);
////    glVertex2f(-sz, -sz+sz2);
////    glEnd();
//
////    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 150);
//	 //senquack - here is a inconsistency, changing this line to just GL_TRIANGLES since we have only 3 vertices
////    glBegin(GL_TRIANGLE_FAN);
//
//	 //senquack - converting to 2D
////    glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz+sz2,  0);
////    glVertex3f( sz, -sz+sz2,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( 0, sz+sz2,  0);
////    glEnd();
//    glBegin(GL_TRIANGLES);
//    glVertex2f(-sz, -sz+sz2);
//    glVertex2f( sz, -sz+sz2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( 0, sz+sz2);
//    glEnd();
//    break;
//  case 6:
//    sz = size/2;
//    glRotatef((float)((cnt*13)&1023)*360/1024, 0, 0, 1);
//
//	 //senquack - no need for this:
////    glDisable(GL_BLEND);
////
////    glBegin(GL_LINE_LOOP);
////    glVertex2f(-sz, -sz);
////    glVertex2f(  0, -sz);
////    glVertex2f( sz,   0);
////    glVertex2f( sz,  sz);
////    glVertex2f(  0,  sz);
////    glVertex2f(-sz,   0);
////    glEnd();
////
////    glEnable(GL_BLEND);
//
//    glColor4i(r, g, b, 210);
//
//	 //senquack - converting to 2D
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f(  0, -sz,  0);
////    glVertex3f( sz,   0,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////    glVertex3f( sz,  sz,  0);
////    glVertex3f(  0,  sz,  0);
////    glVertex3f(-sz,   0,  0);
////    glEnd();
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex2f(-sz, -sz);
//    glVertex2f(  0, -sz);
//    glVertex2f( sz,   0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex2f( sz,  sz);
//    glVertex2f(  0,  sz);
//    glVertex2f(-sz,   0);
//    glEnd();
//
////    glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f(  0, -sz,  0);
////    glVertex3f( sz,   0,  0);
////  glEnd();
////
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f( sz,   0,  0);
////    glVertex3f( sz,  sz,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f( sz,  sz,  0);
////    glVertex3f(  0,  sz,  0);
////  glEnd();
////
////  glBegin(GL_TRIANGLES);
////    glVertex3f(-sz, -sz,  0);
////    glVertex3f(  0,  sz,  0);
////    glVertex3f(-sz,   0,  0);
////    glEnd();
////    break;
//  }
//  glPopMatrix();
//}
void drawShape(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type,
	       int r, int g, int b) {
  GLfloat sz, sz2;
  glPushMatrix();
  glTranslatef(x, y, 0);
//  glColor4i(r, g, b, 255);
  glColor4i(r, g, b, 255);

  //senquack - converting to 2D for speed:
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
  glVertex2f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
  glVertex2f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
  glVertex2f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
  glEnd();

  switch ( type ) {
  case 0:
    sz = size/2;
    glRotatef((float)d*360/1024, 0, 0, 1);

	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glVertex3f( 0, size,  0);
//    glEnd();
    glEnable(GL_BLEND);

//    glColor4i(r, g, b, 150);
    glColor4i(r, g, b, 150);

	 //senquack - converting to 2D for speed:
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( 0, size,  0);
//    glEnd();
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz);
    glVertex2f( sz, -sz);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( 0, size);
    glEnd();
    break;
  case 1:
    sz = size/2;
    glRotatef((float)((cnt*23)&1023)*360/1024, 0, 0, 1);

	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(  0, -size,  0);
//    glVertex3f( sz,     0,  0);
//    glVertex3f(  0,  size,  0);
//    glVertex3f(-sz,     0,  0);
//    glEnd();
    glEnable(GL_BLEND);

//    glColor4i(r, g, b, 180);
    glColor4i(r, g, b, 180);

	 //senquack - converting to 2D for speed:
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(  0, -size,  0);
//    glVertex3f( sz,     0,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f(  0,  size,  0);
//    glVertex3f(-sz,     0,  0);
//    glEnd();
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(  0, -size);
    glVertex2f( sz,     0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f(  0,  size);
    glVertex2f(-sz,     0);
    glEnd();
    break;
  case 2:
    sz = size/4; sz2 = size/3*2;
    glRotatef((float)d*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz2,  0);
//    glVertex3f( sz, -sz2,  0);
//    glVertex3f( sz,  sz2,  0);
//    glVertex3f(-sz,  sz2,  0);
//    glEnd();

	 //senquack - converting to 2D for speed:
//    glEnable(GL_BLEND);
////    glColor4i(r, g, b, 120);
//    glColor4i(r, g, b, 120);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz2,  0);
//    glVertex3f( sz, -sz2,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz, sz2,  0);
//    glVertex3f(-sz, sz2,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 120);
    glColor4i(r, g, b, 120);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz2);
    glVertex2f( sz, -sz2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( sz, sz2);
    glVertex2f(-sz, sz2);
    glEnd();
    break;
  case 3:
    sz = size/2;
    glRotatef((float)((cnt*37)&1023)*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(-sz,  sz,  0);
//    glEnd();

	 //senquack - converting to 2D for speed:
//    glEnable(GL_BLEND);
////    glColor4i(r, g, b, 180);
//    glColor4i(r, g, b, 180);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f( sz, -sz,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(-sz,  sz,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 180);
    glColor4i(r, g, b, 180);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz);
    glVertex2f( sz, -sz);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( sz,  sz);
    glVertex2f(-sz,  sz);
    glEnd();
    break;
  case 4:
    sz = size/2;
    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 220);
    glColor4i(r, g, b, 220);

	 //senquack - converting to 2D for speed:
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz/2, -sz);
    glVertex2f( sz/2, -sz);
    glVertex2f( sz,  -sz/2);
    glVertex2f( sz,   sz/2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( sz/2,  sz);
    glVertex2f(-sz/2,  sz);
    glVertex2f(-sz,   sz/2);
    glVertex2f(-sz,  -sz/2);
    glEnd();
    break;
  case 5:
    sz = size*2/3; sz2 = size/5;
    glRotatef((float)d*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_STRIP);
//    glVertex3f(-sz, -sz+sz2,  0);
//    glVertex3f( 0, sz+sz2,  0);
//    glVertex3f( sz, -sz+sz2,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 150);
    glColor4i(r, g, b, 150);

	 //senquack - converting to 2D for speed:
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz+sz2);
    glVertex2f( sz, -sz+sz2);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( 0, sz+sz2);
    glEnd();
    break;
  case 6:
    sz = size/2;
    glRotatef((float)((cnt*13)&1023)*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glDisable(GL_BLEND);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f(  0, -sz,  0);
//    glVertex3f( sz,   0,  0);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(  0,  sz,  0);
//    glVertex3f(-sz,   0,  0);
//    glEnd();

	 //senquack - converting to 2D for speed:
//    glEnable(GL_BLEND);
////    glColor4i(r, g, b, 210);
//    glColor4i(r, g, b, 210);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz,  0);
//    glVertex3f(  0, -sz,  0);
//    glVertex3f( sz,   0,  0);
////    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
//    glVertex3f( sz,  sz,  0);
//    glVertex3f(  0,  sz,  0);
//    glVertex3f(-sz,   0,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(r, g, b, 210);
    glColor4i(r, g, b, 210);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz);
    glVertex2f(  0, -sz);
    glVertex2f( sz,   0);
//    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glColor4i(SHAPE_BASE_COLOR_R, SHAPE_BASE_COLOR_G, SHAPE_BASE_COLOR_B, 150);
    glVertex2f( sz,  sz);
    glVertex2f(  0,  sz);
    glVertex2f(-sz,   0);
    glEnd();
    break;
  }
  glPopMatrix();
}
static int ikaClr[2][3][3] = {
  {{230, 230, 255}, {100, 100, 200}, {50, 50, 150}},
  {{0, 0, 0}, {200, 0, 0}, {100, 0, 0}},
};

//senquack - IKA mode causes immediate freezing too, trying to fix that:
//void drawShapeIka(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type, int c) {
//  GLfloat sz, sz2, sz3;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
//  glDisable(GL_BLEND);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
//  switch ( type ) {
//  case 0:
//    sz = size/2; sz2 = sz/3; sz3 = size*2/3;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz, -sz3,  0);
//    glVertex3f( sz2, sz3,  0);
//    glVertex3f(-sz2, sz3,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz, -sz3,  0);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glVertex3f( sz2, sz3,  0);
//    glVertex3f(-sz2, sz3,  0);
//    glEnd();
//    break;
//  case 1:
//    sz = size/2;
//    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
//    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
//    break;
//  }
//  glPopMatrix();
//}
//void drawShapeIka(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type, int c) {
//  GLfloat sz, sz2, sz3;
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
//  glDisable(GL_BLEND);
//
//  //senquack
////  glBegin(GL_TRIANGLE_FAN);
////  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
////  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
////  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
////  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
////  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
//
//
//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
//  switch ( type ) {
//  case 0:
//    sz = size/2; sz2 = sz/3; sz3 = size*2/3;
//    glRotatef((float)d*360/1024, 0, 0, 1);
//	 //senquack
////    glBegin(GL_LINE_LOOP);
////    glVertex3f(-sz, -sz3,  0);
////    glVertex3f( sz, -sz3,  0);
////    glVertex3f( sz2, sz3,  0);
////    glVertex3f(-sz2, sz3,  0);
////    glEnd();
//    glBegin(GL_LINES);
//    glVertex2f(-sz, -sz3);
//    glVertex2f( sz, -sz3);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz, -sz3);
//    glVertex2f( sz2, sz3);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz2, sz3);
//    glVertex2f(-sz2, sz3);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f(-sz2, sz3);
//    glVertex2f(-sz, -sz3);
//    glEnd();
//
//    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
//
//	 //senquack
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz, -sz3,  0);
////    glVertex3f( sz, -sz3,  0);
////    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
////    glVertex3f( sz2, sz3,  0);
////    glVertex3f(-sz2, sz3,  0);
////    glEnd();
//    glBegin(GL_TRIANGLES);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz, -sz3,  0);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glVertex3f( sz2, sz3,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz2, sz3,  0);
//    glVertex3f(-sz2, sz3,  0);
//    glEnd();
//    break;
//  case 1:
//    sz = size/2;
//    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
//	 //senquack
////    glBegin(GL_LINE_LOOP);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
////    glEnd();
//    glBegin(GL_LINES);
//    glVertex2f(-sz/2, -sz);
//    glVertex2f( sz/2, -sz);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz/2, -sz);
//    glVertex2f( sz,  -sz/2);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz,  -sz/2);
//    glVertex2f( sz,   sz/2);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz,   sz/2);
//    glVertex2f( sz/2,  sz);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f( sz/2,  sz);
//    glVertex2f(-sz/2,  sz);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f(-sz/2,  sz);
//    glVertex2f(-sz,   sz/2);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f(-sz,   sz/2);
//    glVertex2f(-sz,  -sz/2);
//  glEnd();
//
//  glBegin(GL_LINES);
//    glVertex2f(-sz,  -sz/2);
//    glVertex2f(-sz/2, -sz);
//    glEnd();
//
//
//    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
//
//	 //senquack
////    glBegin(GL_TRIANGLE_FAN);
////    glVertex3f(-sz/2, -sz,  0);
////    glVertex3f( sz/2, -sz,  0);
////    glVertex3f( sz,  -sz/2,  0);
////    glVertex3f( sz,   sz/2,  0);
////    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
////    glVertex3f( sz/2,  sz,  0);
////    glVertex3f(-sz/2,  sz,  0);
////    glVertex3f(-sz,   sz/2,  0);
////    glVertex3f(-sz,  -sz/2,  0);
////    glEnd();
//    glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//  glEnd();
//
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glVertex3f( sz/2,  sz,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
//    break;
//  }
//  glPopMatrix();
//}
void drawShapeIka(GLfloat x, GLfloat y, GLfloat size, int d, int cnt, int type, int c) {
  GLfloat sz, sz2, sz3;
  glPushMatrix();
  glTranslatef(x, y, 0);
//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
  glDisable(GL_BLEND);

  //senquack - converting to 2D for speed
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE,  0);
//  glVertex3f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glVertex3f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE,  0);
//  glEnd();
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(-SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
  glVertex2f( SHAPE_POINT_SIZE, -SHAPE_POINT_SIZE);
  glVertex2f( SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
  glVertex2f(-SHAPE_POINT_SIZE,  SHAPE_POINT_SIZE);
  glEnd();

//  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
  glColor4i(ikaClr[c][0][0], ikaClr[c][0][1], ikaClr[c][0][2], 255);
  switch ( type ) {
  case 0:
    sz = size/2; sz2 = sz/3; sz3 = size*2/3;
    glRotatef((float)d*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz, -sz3,  0);
//    glVertex3f( sz2, sz3,  0);
//    glVertex3f(-sz2, sz3,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);

	 //senquack - converting to 2D for speed
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz, -sz3,  0);
//    glVertex3f( sz, -sz3,  0);
////    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glVertex3f( sz2, sz3,  0);
//    glVertex3f(-sz2, sz3,  0);
//    glEnd();
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz, -sz3);
    glVertex2f( sz, -sz3);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
    glVertex2f( sz2, sz3);
    glVertex2f(-sz2, sz3);
    glEnd();
    break;
  case 1:
    sz = size/2;
    glRotatef((float)((cnt*53)&1023)*360/1024, 0, 0, 1);
	 //senquack - no need for this
//    glBegin(GL_LINE_LOOP);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
    glEnable(GL_BLEND);
//    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);
    glColor4i(ikaClr[c][1][0], ikaClr[c][1][1], ikaClr[c][1][2], 250);

	 //senquack - converting to 2D for speed:
//    glBegin(GL_TRIANGLE_FAN);
//    glVertex3f(-sz/2, -sz,  0);
//    glVertex3f( sz/2, -sz,  0);
//    glVertex3f( sz,  -sz/2,  0);
//    glVertex3f( sz,   sz/2,  0);
////    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
//    glVertex3f( sz/2,  sz,  0);
//    glVertex3f(-sz/2,  sz,  0);
//    glVertex3f(-sz,   sz/2,  0);
//    glVertex3f(-sz,  -sz/2,  0);
//    glEnd();
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(-sz/2, -sz);
    glVertex2f( sz/2, -sz);
    glVertex2f( sz,  -sz/2);
    glVertex2f( sz,   sz/2);
//    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
    glColor4i(ikaClr[c][2][0], ikaClr[c][2][1], ikaClr[c][2][2], 250);
    glVertex2f( sz/2,  sz);
    glVertex2f(-sz/2,  sz);
    glVertex2f(-sz,   sz/2);
    glVertex2f(-sz,  -sz/2);
    glEnd();
    break;
  }
  glPopMatrix();
}

#define SHOT_WIDTH 0.1
#define SHOT_HEIGHT 0.2

static int shtClr[3][3][3] = {
  {{200, 200, 225}, {50, 50, 200}, {200, 200, 225}},
  {{100, 0, 0}, {100, 0, 0}, {200, 0, 0}},
  {{100, 200, 100}, {50, 100, 50}, {100, 200, 100}},
};

//senquack - 2/11
//void drawShot(GLfloat x, GLfloat y, GLfloat d, int c, float width, float height) {
//  glPushMatrix();
//  glTranslatef(x, y, 0);
//  glRotatef(d, 0, 0, 1);
//  glColor4i(shtClr[c][0][0], shtClr[c][0][1], shtClr[c][0][2], 240);
//  glDisable(GL_BLEND);
//  glBegin(GL_LINES);
//  glVertex3f(-width, -height, 0);
//  glVertex3f(-width,  height, 0);
//  glVertex3f( width, -height, 0);
//  glVertex3f( width,  height, 0);
//  glEnd();
//  glEnable(GL_BLEND);
//
//  glColor4i(shtClr[c][1][0], shtClr[c][1][1], shtClr[c][1][2], 240);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-width, -height, 0);
//  glVertex3f( width, -height, 0);
//  glColor4i(shtClr[c][2][0], shtClr[c][2][1], shtClr[c][2][2], 240);
//  glVertex3f( width,  height, 0);
//  glVertex3f(-width,  height, 0);
//  glEnd();
//  glPopMatrix();
//}
void drawShot(GLfloat x, GLfloat y, GLfloat d, int c, float width, float height) {
  glPushMatrix();
  glTranslatef(x, y, 0);
  glRotatef(d, 0, 0, 1);

  //senquack - no need for this
//  glColor4i(shtClr[c][0][0], shtClr[c][0][1], shtClr[c][0][2], 240);
//  glDisable(GL_BLEND);
//  glBegin(GL_LINE_LOOP);
//  glVertex2f(-width, -height);
//  glVertex2f(-width,  height);
//  glEnd();
//  glBegin(GL_LINE_LOOP);
//  glVertex2f( width, -height);
//  glVertex2f( width,  height);
//  glEnd();
//  glEnable(GL_BLEND);

  glColor4i(shtClr[c][1][0], shtClr[c][1][1], shtClr[c][1][2], 240);

  //senquack
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(-width, -height, 0);
//  glVertex3f( width, -height, 0);
//  glColor4i(shtClr[c][2][0], shtClr[c][2][1], shtClr[c][2][2], 240);
//  glVertex3f( width,  height, 0);
//  glVertex3f(-width,  height, 0);
//  glEnd();
  // 2D version (hopefully a tiny bit faster:)
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(-width, -height);
  glVertex2f( width, -height);
  glColor4i(shtClr[c][2][0], shtClr[c][2][1], shtClr[c][2][2], 240);
  glVertex2f( width,  height);
  glVertex2f(-width,  height);
  glEnd();

  //senquack - converted:
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-width, -height, 0);
//  glVertex3f( width, -height, 0);
//  glColor4i(shtClr[c][2][0], shtClr[c][2][1], shtClr[c][2][2], 240);
//  glVertex3f( width,  height, 0);
//  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(-width, -height, 0);
//  glVertex3f( width,  height, 0);
//  glVertex3f(-width,  height, 0);
//  glEnd();

  glPopMatrix();
}

//senquack - why are there two pushmatrixes here but only one popmatrix in the endDrawBoards() function??
//void startDrawBoards() {
//  glMatrixMode(GL_PROJECTION);
//  glPushMatrix();
//  glLoadIdentity();
//  glOrtho(0, 640, 480, 0, -1, 1);
//  glMatrixMode(GL_MODELVIEW);
//  glPushMatrix();
//  glLoadIdentity();
//}
void startDrawBoards() {
  glMatrixMode(GL_PROJECTION);
  //senquack - dunno why we do this
//  glPushMatrix();
  glLoadIdentity();
  glOrtho(0, 640, 480, 0, -1, 1);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
}

//senquack
//void endDrawBoards() {
//  glPopMatrix();
//  screenResized();
//}
void endDrawBoards() {
  glPopMatrix();
  screenResized();
}

//senquack - 2/11
//static void drawBoard(int x, int y, int width, int height) {
//  glColor4i(0, 0, 0, 255);
//  glBegin(GL_QUADS);
//  glVertex2f(x,y);
//  glVertex2f(x+width,y);
//  glVertex2f(x+width,y+height);
//  glVertex2f(x,y+height);
//  glEnd();
//}
static void drawBoard(int x, int y, int width, int height) {
  glColor4i(0, 0, 0, 255);

  //senquack
//  glBegin(GL_QUADS);
//  glVertex2f(x,y);
//  glVertex2f(x+width,y);
//  glVertex2f(x+width,y+height);
//  glVertex2f(x,y+height);
//  glEnd();
  glBegin(GL_QUADS);
  glVertex3f(x,y,0);
  glVertex3f(x+width,y,0);
  glVertex3f(x+width,y+height,0);
  glVertex3f(x,y+height,0);
  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(x,y,0);
//  glVertex3f(x+width,y,0);
//  glVertex3f(x+width,y+height,0);
//  glEnd();
//  glBegin(GL_TRIANGLES);
//  glVertex3f(x,y,0);
//  glVertex3f(x+width,y+height,0);
//  glVertex3f(x,y+height,0);
//  glEnd();
}

//senquack - 2/11
//void drawSideBoards() {
//  glDisable(GL_BLEND);
//  drawBoard(0, 0, 160, 480);
//  drawBoard(480, 0, 160, 480);
//  glEnable(GL_BLEND);
//  drawScore();
//  drawRPanel();
//}
void drawSideBoards() {
	//senquack - since we aren't drawing the background anymore, no need for these
  glDisable(GL_BLEND);
  drawBoard(0, 0, 160, 480);
  drawBoard(480, 0, 160, 480);
  glEnable(GL_BLEND);
  drawScore();
  drawRPanel();
}

// 2/11 - new efforts to convert all triangle fans and line loops to something else:
//senquack
//void drawTitleBoard() {
//  
//	//senquack
////  printf("drawTitleBoard() start\n");
//  //glEnable(GL_TEXTURE_2D);
//  printf("*");
//  //glBindTexture(GL_TEXTURE_2D, titleTexture);
//  printf("*");
//  glColor4i(255, 255, 255, 255);
//  printf("*");
//  glBegin(GL_TRIANGLE_FAN);
//  glTexCoord2f(0.0f, 0.0f);
//  glVertex3f(350, 78,  0);
//  glTexCoord2f(1.0f, 0.0f);
//  glVertex3f(470, 78,  0);
//  glTexCoord2f(1.0f, 1.0f);
//  glVertex3f(470, 114,  0);
//  glTexCoord2f(0.0f, 1.0f);
//  glVertex3f(350, 114,  0);
//  printf("*");
//  glEnd();
//  
//  //glDisable(GL_TEXTURE_2D); //TODO: Make sure to uncomment this line if I fix texturing....
//  printf("*");
//  glColor4i(200, 200, 200, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(350, 30, 0);
//  glVertex3f(400, 30, 0);
//  glVertex3f(380, 56, 0);
//  glVertex3f(380, 80, 0);
//  glVertex3f(350, 80, 0);
//  glEnd();
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(404, 80, 0);
//  glVertex3f(404, 8, 0);
//  glVertex3f(440, 8, 0);
//  glVertex3f(440, 44, 0);
//  glVertex3f(465, 80, 0);
//  glEnd();
//  glColor4i(255, 255, 255, 255);
//  glBegin(GL_LINE_LOOP);
//  glVertex3f(350, 30, 0);
//  glVertex3f(400, 30, 0);
//  glVertex3f(380, 56, 0);
//  glVertex3f(380, 80, 0);
//  glVertex3f(350, 80, 0);
//  glEnd();
//  glBegin(GL_LINE_LOOP);
//  glVertex3f(404, 80, 0);
//  glVertex3f(404, 8, 0);
//  glVertex3f(440, 8, 0);
//  glVertex3f(440, 44, 0);
//  glVertex3f(465, 80, 0);
//  glEnd();
//  //senquack
////  printf("Done drawing drawTitleBoard\n"); fflush(stdout);
//}
//senquack - 2nd try
//void drawTitleBoard() {
//  
//	//senquack
////  printf("drawTitleBoard() start\n");
//  //glEnable(GL_TEXTURE_2D);
//  printf("*");
//  //glBindTexture(GL_TEXTURE_2D, titleTexture);
//  printf("*");
//  glColor4i(255, 255, 255, 255);
//  printf("*");
//  glBegin(GL_TRIANGLE_FAN);
//  glTexCoord2f(0.0f, 0.0f);
//  glVertex3f(350, 78,  0);
//  glTexCoord2f(1.0f, 0.0f);
//  glVertex3f(470, 78,  0);
//  glTexCoord2f(1.0f, 1.0f);
//  glVertex3f(470, 114,  0);
//  glTexCoord2f(0.0f, 1.0f);
//  glVertex3f(350, 114,  0);
//  printf("*");
//  glEnd();
//  
//  //glDisable(GL_TEXTURE_2D); //TODO: Make sure to uncomment this line if I fix texturing....
//  printf("*");
//  glColor4i(200, 200, 200, 255);
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(350, 30, 0);
//  glVertex3f(400, 30, 0);
//  glVertex3f(380, 56, 0);
//  glVertex3f(380, 80, 0);
//  glVertex3f(350, 80, 0);
//  glEnd();
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(404, 80, 0);
//  glVertex3f(404, 8, 0);
//  glVertex3f(440, 8, 0);
//  glVertex3f(440, 44, 0);
//  glVertex3f(465, 80, 0);
//  glEnd();
//  glColor4i(255, 255, 255, 255);
//
//  //senquack
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(350, 30, 0);
////  glVertex3f(400, 30, 0);
////  glVertex3f(380, 56, 0);
////  glVertex3f(380, 80, 0);
////  glVertex3f(350, 80, 0);
////  glEnd();
//  glBegin(GL_LINES);
//  glVertex3f(350, 30, 0);
//  glVertex3f(400, 30, 0);
//
//  glVertex3f(400, 30, 0);
//  glVertex3f(380, 56, 0);
//
//  glVertex3f(380, 56, 0);
//  glVertex3f(380, 80, 0);
//
//  glVertex3f(380, 80, 0);
//  glVertex3f(350, 80, 0);
//
//  glVertex3f(350, 80, 0);
//  glVertex3f(350, 30, 0);
//  glEnd();
//
//  //senquack
////  glBegin(GL_LINE_LOOP);
////  glVertex3f(404, 80, 0);
////  glVertex3f(404, 8, 0);
////  glVertex3f(440, 8, 0);
////  glVertex3f(440, 44, 0);
////  glVertex3f(465, 80, 0);
////  glEnd();
//  glBegin(GL_LINES);
//  glVertex3f(404, 80, 0);
//  glVertex3f(404, 8, 0);
//
//  glVertex3f(404, 8, 0);
//  glVertex3f(440, 8, 0);
//
//  glVertex3f(440, 8, 0);
//  glVertex3f(440, 44, 0);
//
//  glVertex3f(440, 44, 0);
//  glVertex3f(465, 80, 0);
//
//  glVertex3f(465, 80, 0);
//  glVertex3f(404, 80, 0);
//  glEnd();
//  //senquack
////  printf("Done drawing drawTitleBoard\n"); fflush(stdout);
//}
//senquack - 3rd try (lines are OK, triangles are way off)
void drawTitleBoard() {
  
	//senquack
//  printf("drawTitleBoard() start\n");
  //glEnable(GL_TEXTURE_2D);
  //glBindTexture(GL_TEXTURE_2D, titleTexture);
//  glColor4i(255, 255, 255, 255);

  //senquack - enabling this causes dozens of vertical stripes to appear instead of anything intelligible
//  glBegin(GL_TRIANGLE_FAN);
//  glTexCoord2f(0.0f, 0.0f);
//  glVertex3f(350, 78,  0);
//  glTexCoord2f(1.0f, 0.0f);
//  glVertex3f(470, 78,  0);
//  glTexCoord2f(1.0f, 1.0f);
//  glVertex3f(470, 114,  0);
//  glTexCoord2f(0.0f, 1.0f);
//  glVertex3f(350, 114,  0);
//  printf("*");
//  glEnd();
  //senquack - changing it to this is no help at all, still has vertical stripes:
//  glBegin(GL_TRIANGLE_FAN);
//  glVertex3f(350, 78,  0);
//  glVertex3f(470, 78,  0);
//  glVertex3f(470, 114,  0);
//  glVertex3f(350, 114,  0);
//  glEnd();
  
  //glDisable(GL_TEXTURE_2D); //TODO: Make sure to uncomment this line if I fix texturing....
  glColor4i(200, 200, 200, 255);

  //senquack - these two don't cause vertical stripes but the triangles are alllll messed up
  glBegin(GL_TRIANGLE_FAN);
  glVertex3f(350, 30, 0);
  glVertex3f(400, 30, 0);
  glVertex3f(380, 56, 0);
  glVertex3f(380, 80, 0);
  glVertex3f(350, 80, 0);
  glEnd();
  glColor4i(200, 200, 200, 255);
  glBegin(GL_TRIANGLE_FAN);
  glVertex3f(404, 80, 0);
  glVertex3f(404, 8, 0);
  glVertex3f(440, 8, 0);
  glVertex3f(440, 44, 0);
  glVertex3f(465, 80, 0);
  glEnd();

  //senquack - test conversions here:
//  glBegin(GL_TRIANGLES);
//  glVertex3f(350, 30, 0);
//  glVertex3f(400, 30, 0);
//  glVertex3f(380, 56, 0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//  glVertex3f(350, 30, 0);
//  glVertex3f(380, 56, 0);
//  glVertex3f(380, 80, 0);
//  glEnd();
//
//  glBegin(GL_TRIANGLES);
//  glVertex3f(350, 30, 0);
//  glVertex3f(380, 80, 0);
//  glVertex3f(350, 80, 0);
//  glEnd();

//  glBegin(GL_TRIANGLES);
//  glVertex3f(404, 80, 0);
//  glVertex3f(404, 8, 0);
//  glVertex3f(440, 8, 0);
//
//  glVertex3f(404, 80, 0);
//  glVertex3f(440, 8, 0);
//  glVertex3f(440, 44, 0);
//
//  glVertex3f(404, 80, 0);
//  glVertex3f(440, 44, 0);
//  glVertex3f(465, 80, 0);
//  glEnd();

  glColor4i(255, 255, 255, 255);

  //senquack
  glBegin(GL_LINE_LOOP);
  glVertex2f(350, 30);
  glVertex2f(400, 30);
  glVertex2f(380, 56);
  glVertex2f(380, 80);
  glVertex2f(350, 80);
  glVertex2f(350, 30);
  glEnd();
//  glBegin(GL_LINES);
//  glVertex2f(350, 30);
//  glVertex2f(400, 30);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(400, 30);
//  glVertex2f(380, 56);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(380, 56);
//  glVertex2f(380, 80);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(380, 80);
//  glVertex2f(350, 80);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(350, 80);
//  glVertex2f(350, 30);
//  glEnd();

  //senquack
  glBegin(GL_LINE_LOOP);
  glVertex2f(404, 80);
  glVertex2f(404, 8);
  glVertex2f(440, 8);
  glVertex2f(440, 44);
  glVertex2f(465, 80);
  glVertex2f(404, 80);
  glEnd();
//  glBegin(GL_LINES);
//  glVertex2f(404, 80);
//  glVertex2f(404, 8);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(404, 8);
//  glVertex2f(440, 8);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(440, 8);
//  glVertex2f(440, 44);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(440, 44);
//  glVertex2f(465, 80);
//  glEnd();
//
//  glBegin(GL_LINES);
//  glVertex2f(465, 80);
//  glVertex2f(404, 80);
//  glEnd();
  //senquack
//  printf("Done drawing drawTitleBoard\n"); fflush(stdout);
}

// Draw the numbers.
int drawNum(int n, int x ,int y, int s, int r, int g, int b) {
  for ( ; ; ) {
    drawLetter(n%10, x, y, s, 3, r, g, b);
    y += s*1.7f;
    n /= 10;
    if ( n <= 0 ) break;
  }
  return y;
}

int drawNumRight(int n, int x ,int y, int s, int r, int g, int b) {
  int d, nd, drawn = 0;
  for ( d = 100000000 ; d > 0 ; d /= 10 ) {
    nd = (int)(n/d);
    if ( nd > 0 || drawn ) {
      n -= d*nd;
      drawLetter(nd%10, x, y, s, 1, r, g, b);
      y += s*1.7f;
      drawn = 1;
    }
  }
  if ( !drawn ) {
    drawLetter(0, x, y, s, 1, r, g, b);
    y += s*1.7f;
  }
  return y;
}

int drawNumCenter(int n, int x ,int y, int s, int r, int g, int b) {
  for ( ; ; ) {
    drawLetter(n%10, x, y, s, 0, r, g, b);
    x -= s*1.7f;
    n /= 10;
    if ( n <= 0 ) break;
  }
  return y;
}

int drawTimeCenter(int n, int x ,int y, int s, int r, int g, int b) {
  int i;
  for ( i=0 ; i<7 ; i++ ) {
    if ( i != 4 ) {
      drawLetter(n%10, x, y, s, 0, r, g, b);
      n /= 10;
    } else {
      drawLetter(n%6, x, y, s, 0, r, g, b);
      n /= 6;
    }
    if ( (i&1) == 1 || i == 0 ) {
      switch ( i ) {
      case 3:
	drawLetter(41, x+s*1.16f, y, s, 0, r, g, b);
	break;
      case 5:
	drawLetter(40, x+s*1.16f, y, s, 0, r, g, b);
	break;
      }
      x -= s*1.7f;
    } else {
      x -= s*2.2f;
    }
    if ( n <= 0 ) break;
  }
  return y;
}

#define JOYSTICK_AXIS 16384

int getPadState() {
  int x = 0, y = 0;
  int pad = 0;
  int gp2x_up = 0, gp2x_upleft = 0, gp2x_left = 0, gp2x_downleft = 0, gp2x_down = 0, 
  	  gp2x_downright = 0, gp2x_right = 0, gp2x_upright = 0; 
  	  
  if ( stick != NULL ) {
    //x = SDL_JoystickGetAxis(stick, 0);
    //y = SDL_JoystickGetAxis(stick, 1);
    
    gp2x_up = SDL_JoystickGetButton(stick, GP2X_BUTTON_UP);
    gp2x_upleft = SDL_JoystickGetButton(stick, GP2X_BUTTON_UPLEFT);
    gp2x_left = SDL_JoystickGetButton(stick, GP2X_BUTTON_LEFT);
    gp2x_downleft = SDL_JoystickGetButton(stick, GP2X_BUTTON_DOWNLEFT);
    gp2x_down = SDL_JoystickGetButton(stick, GP2X_BUTTON_DOWN);
    gp2x_downright = SDL_JoystickGetButton(stick, GP2X_BUTTON_DOWNRIGHT);
    gp2x_right = SDL_JoystickGetButton(stick, GP2X_BUTTON_RIGHT);
    gp2x_upright = SDL_JoystickGetButton(stick, GP2X_BUTTON_UPRIGHT);  
    
  }
  
  //senquack
//  if ( keys[SDLK_RIGHT] == SDL_PRESSED || keys[SDLK_KP6] == SDL_PRESSED || x > JOYSTICK_AXIS || gp2x_right || gp2x_downright || gp2x_upright) {
//    pad |= PAD_RIGHT;
//  }
//  if ( keys[SDLK_LEFT] == SDL_PRESSED || keys[SDLK_KP4] == SDL_PRESSED || x < -JOYSTICK_AXIS || gp2x_left || gp2x_downleft || gp2x_upleft) {
//    pad |= PAD_LEFT;
//  }
//  if ( keys[SDLK_DOWN] == SDL_PRESSED || keys[SDLK_KP2] == SDL_PRESSED || y > JOYSTICK_AXIS || gp2x_down || gp2x_downright || gp2x_downleft) {
//    pad |= PAD_DOWN;
//  }
//  if ( keys[SDLK_UP] == SDL_PRESSED ||  keys[SDLK_KP8] == SDL_PRESSED || y < -JOYSTICK_AXIS || gp2x_up || gp2x_upright || gp2x_upleft) {
//    pad |= PAD_UP;
//  }
  if ( gp2x_right || gp2x_downright || gp2x_upright) {
    pad |= PAD_RIGHT;
  }
  if ( gp2x_left || gp2x_downleft || gp2x_upleft) {
    pad |= PAD_LEFT;
  }
  if ( gp2x_down || gp2x_downright || gp2x_downleft) {
    pad |= PAD_DOWN;
  }
  if ( gp2x_up || gp2x_upright || gp2x_upleft) {
    pad |= PAD_UP;
  }
  
  return pad;
}

int buttonReversed = 0;

//senquack - added to allow the laser to always be firing *except* when the fire button is pressed:
int laserOnByDefault = 0;

int getButtonState() {
  int btn = 0;
  int btn1 = 0, btn2 = 0;
  int btn_volup = 0, btn_voldown = 0;
//  int volchanged = 0;
  
  // Albert's original code:
//  if ( stick != NULL ) {
//    btn1 = SDL_JoystickGetButton(stick, GP2X_BUTTON_B);
//    //btn2 = SDL_JoystickGetButton(stick, 1);
//    //btn3 = SDL_JoystickGetButton(stick, 2);
//    //btn4 = SDL_JoystickGetButton(stick, 3);
//    btn2 = SDL_JoystickGetButton(stick, GP2X_BUTTON_X);
//    btn3 = SDL_JoystickGetButton(stick, GP2X_BUTTON_Y);
//    btn4 = SDL_JoystickGetButton(stick, GP2X_BUTTON_A);
//    btn5 = SDL_JoystickGetButton(stick, GP2X_BUTTON_START);
//    btn6 = SDL_JoystickGetButton(stick, GP2X_BUTTON_L);
//    btn_volup = SDL_JoystickGetButton(stick, GP2X_BUTTON_VOLUP);
//    btn_voldown = SDL_JoystickGetButton(stick, GP2X_BUTTON_VOLDOWN);
//
//  }
  if ( stick != NULL ) {
    btn1 = SDL_JoystickGetButton(stick, GP2X_BUTTON_B) |
				 SDL_JoystickGetButton(stick, GP2X_BUTTON_Y) |
				 SDL_JoystickGetButton(stick, GP2X_BUTTON_R);

    btn2 = SDL_JoystickGetButton(stick, GP2X_BUTTON_X) |
				SDL_JoystickGetButton(stick, GP2X_BUTTON_A) |
				SDL_JoystickGetButton(stick, GP2X_BUTTON_L);

//    btn3 = SDL_JoystickGetButton(stick, GP2X_BUTTON_Y);
//    btn4 = SDL_JoystickGetButton(stick, GP2X_BUTTON_A);

//    btn_quit = SDL_JoystickGetButton(stick, GP2X_BUTTON_SELECT);	
//	 btn_pause = SDL_JoystickGetButton(stick, GP2X_BUTTON_START);	

    btn_volup = SDL_JoystickGetButton(stick, GP2X_BUTTON_VOLUP);
    btn_voldown = SDL_JoystickGetButton(stick, GP2X_BUTTON_VOLDOWN);
  }

//  if ( keys[SDLK_z] == SDL_PRESSED || btn1 ) {
  if ( btn1 ) {
    if ( !buttonReversed ) {
      //printf("pressed!!!\n\n\n\n\n");
      btn |= PAD_BUTTON1;
    } else {
      btn |= PAD_BUTTON2;
    }
  }
//  if ( keys[SDLK_x] == SDL_PRESSED || btn2 ) {
  if ( btn2 ) {
    if ( !buttonReversed ) {
      btn |= PAD_BUTTON2;
    } else {
      btn |= PAD_BUTTON1;
    }
  }
  
  if (btn_voldown) {
	  gp2x_change_volume(-2);
  } else if (btn_volup) {
	  gp2x_change_volume(2);
  }
  
  //senquack - this was the cause of the segfault on exit Albert got:
  //Quit
//  if (btn5)
//  	closeSDL();
  //senquack - my temporary replacement code:
//  if (btn_quit) done = 1;
//  if (btn_quit) 
//	  btn |= PAD_BUTTON_QUIT;
  
  return btn;
}

// to perform cross product between 2 vectors in FadiGluLookAt
//void CrossProd(float x1, float y1, float z1, float x2, float y2, float z2, float res[3])
//{
//	res[0] = y1*z2 - y2*z1;
//	res[1] = x2*z1 - x1*z2;
//	res[2] = x1*y2 - x2*y1;
//}

//senquack - it appears that Albert added these implementations of gluLookAt:
// crappy implementation
//void FadiGluLookAt(float eyeX, float eyeY, float eyeZ, float lookAtX, float lookAtY, float lookAtZ, float upX, float upY, float upZ)
//{
//	// i am not using here proper implementation for vectors.
//	// if you want, you can replace the arrays with your own
//	// vector types
//	float f[3];
//
//	// calculating the viewing vector
//	f[0] = lookAtX - eyeX;
//	f[1] = lookAtY - eyeY;
//	f[2] = lookAtZ - eyeZ;
//
//	float fMag, upMag;
//	fMag = sqrt(f[0]*f[0] + f[1]*f[1] + f[2]*f[2]); //Optimize me - GP2X!
//	upMag = sqrt(upX*upX + upY*upY + upZ*upZ);
//	//Math::Sqrt(fMag, f[0]*f[0] + f[1]*f[1] + f[2]*f[2]);
//	//Math::Sqrt(upMag, upX*upX + upY*upY + upZ*upZ);
//
//	// normalizing the viewing vector
//	if( fMag != 0)
//	{
//		f[0] = f[0]/fMag;
//		f[1] = f[1]/fMag;
//		f[2] = f[2]/fMag;
//	}
//
//	// normalising the up vector. no need for this here if you have your
//	// up vector already normalised, which is mostly the case.
//	if( upMag != 0 )
//	{
//		upX = upX/upMag;
//		upY = upY/upMag;
//		upZ = upZ/upMag;
//	}
//
//	float s[3], u[3];
//
//	CrossProd(f[0], f[1], f[2], upX, upY, upZ, s);
//	CrossProd(s[0], s[1], s[2], f[0], f[1], f[2], u);
//
//	float M[]=
//	{
//	s[0], u[0], -f[0], 0,
//	s[1], u[1], -f[1], 0,
//	s[2], u[2], -f[2], 0,
//	0, 0, 0, 1
//	};
//
//	glMultMatrixf(M);
//	glTranslatef (-eyeX, -eyeY, -eyeZ);
//}

//senquack - it appears that Albert added these implementations of gluLookAt:
//Mesa's implementation, switched to floats from doubles in a desparate attempt at getting more speed.
//senquack - for wiz OpenGLES, we disable our internal version:
void gluLookAt(GLfloat eyex, GLfloat eyey, GLfloat eyez,
	  GLfloat centerx, GLfloat centery, GLfloat centerz,
	  GLfloat upx, GLfloat upy, GLfloat upz)
{
   GLfloat m[16];
   GLfloat x[3], y[3], z[3];
   GLfloat mag;

   /* Make rotation matrix */

   /* Z vector */
   z[0] = eyex - centerx;
   z[1] = eyey - centery;
   z[2] = eyez - centerz;
   mag = sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
   if (mag) {			/* mpichler, 19950515 */
      z[0] /= mag;
      z[1] /= mag;
      z[2] /= mag;
   }

   /* Y vector */
   y[0] = upx;
   y[1] = upy;
   y[2] = upz;

   /* X vector = Y cross Z */
   x[0] = y[1] * z[2] - y[2] * z[1];
   x[1] = -y[0] * z[2] + y[2] * z[0];
   x[2] = y[0] * z[1] - y[1] * z[0];

   /* Recompute Y = Z cross X */
   y[0] = z[1] * x[2] - z[2] * x[1];
   y[1] = -z[0] * x[2] + z[2] * x[0];
   y[2] = z[0] * x[1] - z[1] * x[0];

   /* mpichler, 19950515 */
   /* cross product gives area of parallelogram, which is < 1.0 for
    * non-perpendicular unit-length vectors; so normalize x, y here
    */

   mag = sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
   if (mag) {
      x[0] /= mag;
      x[1] /= mag;
      x[2] /= mag;
   }

   mag = sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);
   if (mag) {
      y[0] /= mag;
      y[1] /= mag;
      y[2] /= mag;
   }

#define M(row,col)  m[col*4+row]
   M(0, 0) = x[0];
   M(0, 1) = x[1];
   M(0, 2) = x[2];
   M(0, 3) = 0.0;
   M(1, 0) = y[0];
   M(1, 1) = y[1];
   M(1, 2) = y[2];
   M(1, 3) = 0.0;
   M(2, 0) = z[0];
   M(2, 1) = z[1];
   M(2, 2) = z[2];
   M(2, 3) = 0.0;
   M(3, 0) = 0.0;
   M(3, 1) = 0.0;
   M(3, 2) = 0.0;
   M(3, 3) = 1.0;
#undef M
   glMultMatrixf(m);

   /* Translate Eye to Origin */
   glTranslatef(-eyex, -eyey, -eyez);

}

//senquack - 2/11 - disabled for now:
//Added by Albert to help with surface format conversion:
/*
 * SDL surface conversion to OpenGL texture formats
 *
 * Mattias Engdegrd
 *
 * Use, modification and distribution of this source is allowed without
 * limitation, warranty or liability of any kind.
 */

/*
 * Convert a surface into one suitable as an OpenGL texture;
 * in RGBA format if want_alpha is nonzero, or in RGB format otherwise.
 * 
 * The surface may have a colourkey, which is then translated to an alpha
 * channel if RGBA is desired.
 *
 * Return the resulting texture, or NULL on error. The original surface is
 * always freed.
 */
//SDL_Surface *conv_surf_gl(SDL_Surface *s, int want_alpha)
//{
//    Uint32 rmask, gmask, bmask, amask;
//    SDL_Surface *conv;
//    int bpp = want_alpha ? 32 : 24;
//
//    /* SDL interprets each pixel as a 24 or 32-bit number, so our
//       masks must depend on the endianness (byte order) of the
//       machine. */
//#if SDL_BYTEORDER == SDL_BIG_ENDIAN
//    rmask = 0xff000000 >> (32 - bpp);
//    gmask = 0x00ff0000 >> (32 - bpp);
//    bmask = 0x0000ff00 >> (32 - bpp);
//    amask = 0x000000ff >> (32 - bpp);
//#else
//    rmask = 0x000000ff;
//    gmask = 0x0000ff00;
//    bmask = 0x00ff0000;
//    amask = want_alpha ? 0xff000000 : 0;
//#endif
//
//    /* check if the surface happens to be in the right format */
//    if(s->format->BitsPerPixel == bpp
//       && s->format->Rmask == rmask
//       && s->format->Gmask == gmask
//       && s->format->Bmask == bmask
//       && s->format->Amask == amask
//       && !(s->flags & SDL_SRCCOLORKEY)) {
//	/* no conversion needed */
//	return s;
//    }
//
//    /* wrong format, conversion necessary */
//
//    /* SDL surfaces are created with lines padded to start at 32-bit boundaries
//       which suits OpenGL well (as long as GL_UNPACK_ALIGNMENT remains
//       unchanged from its initial value of 4) */
//    conv = SDL_CreateRGBSurface(SDL_SWSURFACE, s->w, s->h, bpp,
//				rmask, gmask, bmask, amask);
//    if(!conv) {
//	SDL_FreeSurface(conv);
//	return NULL;
//    }
//
//    if(want_alpha) {
//	/* SDL sets the SDL_SRCALPHA flag on all surfaces with an
//	   alpha channel. We need to clear that flag for the copy,
//	   since SDL would attempt to alpha-blend our image otherwise */
//	SDL_SetAlpha(s, 0, 255);
//    }
//
//    /*
//     * Do the conversion. If the source surface has a colourkey, then it
//     * will be used in the blit. We use the fact that newly created software
//     * surfaces are zero-filled, so the pixels not blitted will remain
//     * transparent.
//     */
//    if(SDL_BlitSurface(s, NULL, conv, NULL) < 0) {
//	/* blit error */
//	SDL_FreeSurface(conv);
//	conv = NULL;
//    }
//    SDL_FreeSurface(s);
//
//    return conv;
//}

//senquack - 2/11 - disabled for now:
/*
 * A sample use of conv_surf_gl():
 *
 * Load an image from a file, and convert it to RGB or RGBA format,
 * depending on the image.
 *
 * Return the resulting surface, or NULL on error
 */
//SDL_Surface *load_gl_texture(char *file)
//{
//    SDL_Surface *s = IMG_Load(file);
//    if(!s)
//	   return NULL;
//    return conv_surf_gl(s, s->format->Amask || (s->flags & SDL_SRCCOLORKEY));
//}


